-- $Id$
module Observer;

create OBSERVER : OBSERVERM from ACCESSORS : ACCESSORSM, OBSERVERTYPES : MERGEMODEL;

uses Java;

-- ======================================================================
-- model merge helpers begin
-- ======================================================================
-- From: ModelMerge.atl 1174 2005-05-23 07:38:38Z dwagelaa

helper context ACCESSORSM!ModelElement def : isInPackage() : Boolean =
	not ACCESSORSM!Package.allInstances()->select(p|
		p=self.namespace and p.oclIsTypeOf(ACCESSORSM!Package))->isEmpty();

helper context ACCESSORSM!ModelElement def : qName() : String =
	if self.isInPackage() then
		self.namespace.qName() + '.' + self.name
	else
		self.name
	endif;

helper context MERGEMODEL!ModelElement def : isInPackage() : Boolean =
	not MERGEMODEL!Package.allInstances()->select(p|
		p=self.namespace and p.oclIsTypeOf(MERGEMODEL!Package))->isEmpty();

helper context MERGEMODEL!ModelElement def : qName() : String =
	if self.isInPackage() then
		self.namespace.qName() + '.' + self.name
	else
		self.name
	endif;

helper context MERGEMODEL!Model def : notInSourceModel() : Boolean =
	false;

helper context MERGEMODEL!Model def : fromSourceModel() : ACCESSORSM!Model =
	ACCESSORSM!Model.allInstances()->asSequence()->first();

helper context MERGEMODEL!Classifier def : notInSourceModel() : Boolean =
	ACCESSORSM!Classifier.allInstances()->select(e|e.qName()=self.qName())->isEmpty();

helper context MERGEMODEL!Classifier def : fromSourceModel() : ACCESSORSM!Classifier =
	ACCESSORSM!Classifier.allInstances()->select(e|e.qName()=self.qName())->first();

helper context MERGEMODEL!Package def : notInSourceModel() : Boolean =
	ACCESSORSM!Package.allInstances()->select(e|e.qName()=self.qName())->isEmpty();

helper context MERGEMODEL!Package def : fromSourceModel() : ACCESSORSM!Package =
	ACCESSORSM!Package.allInstances()->select(e|e.qName()=self.qName())->first();

helper context MERGEMODEL!TagDefinition def : notInSourceModel() : Boolean =
	ACCESSORSM!TagDefinition.allInstances()->select(e|e.qName()=self.qName())->isEmpty();

helper context MERGEMODEL!TagDefinition def : fromSourceModel() : ACCESSORSM!TagDefinition =
	ACCESSORSM!TagDefinition.allInstances()->select(e|e.qName()=self.qName())->first();

helper context MERGEMODEL!Stereotype def : notInSourceModel() : Boolean =
	ACCESSORSM!Stereotype.allInstances()->select(e|e.qName()=self.qName())->isEmpty();

helper context MERGEMODEL!Stereotype def : fromSourceModel() : ACCESSORSM!Stereotype =
	ACCESSORSM!Stereotype.allInstances()->select(e|e.qName()=self.qName())->first();

helper context MERGEMODEL!Association def : notInSourceModel() : Boolean =
	not self.connection->forAll(c|c.inSourceModel());

helper context MERGEMODEL!AssociationEnd def : inSourceModel() : Boolean =
	if self.isNavigable then
		not ACCESSORSM!AssociationEnd.allInstances()->select(e|e.isNavigable)->select(e|
			e.name=self.name and e.participant.qName()=self.participant.qName())->isEmpty()
	else if self.otherEnd().isNavigable then
		self.otherEnd().inSourceModel()
	else
		true
	endif endif;

helper context MERGEMODEL!AssociationEnd def : notInSourceModel() : Boolean =
	self.association.notInSourceModel();

helper context MERGEMODEL!AssociationEnd def : otherEnd() : MERGEMODEL!AssociationEnd =
	self.association.connection->select(x|x<>self)->first();

helper context MERGEMODEL!TaggedValue def : notInSourceModel() : Boolean =
	self.modelElement.notInSourceModel();

helper context MERGEMODEL!Feature def : notInSourceModel() : Boolean =
	self.owner.notInSourceModel();

helper context MERGEMODEL!Expression def : notInSourceModel() : Boolean =
	if not MERGEMODEL!Attribute.allInstances()->select(a|a.initialValue=self)->isEmpty() then
		MERGEMODEL!Attribute.allInstances()->select(a|a.initialValue=self)->first().notInSourceModel()
	else if	not MERGEMODEL!Method.allInstances()->select(m|m.body=self)->isEmpty() then
		MERGEMODEL!Method.allInstances()->select(m|m.body=self)->first().notInSourceModel()
	else
		false
	endif endif;

helper context MERGEMODEL!Dependency def : notInSourceModel() : Boolean =
	ACCESSORSM!Dependency.allInstances()->select(d|
		d.supplier->forAll(s1|self.supplier->forAll(s2|s1.qName()=s2.qName())) and
		d.client->forAll(c1|self.client->forAll(c2|c1.qName()=c2.qName())))->isEmpty();

helper context MERGEMODEL!Generalization def : notInSourceModel() : Boolean =
	ACCESSORSM!Generalization.allInstances()->select(g|
		g.parent.qName()=self.parent.qName() and
		g.child.qName()=self.child.qName())->isEmpty();

helper context MERGEMODEL!Multiplicity def : notInSourceModel() : Boolean =
	if not MERGEMODEL!StructuralFeature.allInstances()->select(e|e.multiplicity=self)->isEmpty() then
		MERGEMODEL!StructuralFeature.allInstances()->select(e|e.multiplicity=self)->first().notInSourceModel()
	else if	not MERGEMODEL!AssociationEnd.allInstances()->select(e|e.multiplicity=self)->isEmpty() then
		MERGEMODEL!AssociationEnd.allInstances()->select(e|e.multiplicity=self)->first().notInSourceModel()
	else if	not MERGEMODEL!TagDefinition.allInstances()->select(e|e.multiplicity=self)->isEmpty() then
		MERGEMODEL!TagDefinition.allInstances()->select(e|e.multiplicity=self)->first().notInSourceModel()
	else
		false
	endif endif endif;

helper context MERGEMODEL!MultiplicityRange def : notInSourceModel() : Boolean =
	self.multiplicity.notInSourceModel();

helper context MERGEMODEL!Parameter def : notInSourceModel() : Boolean =
	self.behavioralFeature.notInSourceModel();

-- ======================================================================
-- model merge helpers end
-- ======================================================================

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context ACCESSORSM!Attribute def : javaSetterNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (this.' + self.name + ' != ' + self.name + ') {\n' +
	'    // Begin original body\n' +
	body +
	'\n    // End original body\n' +
	self.name.notifyStanza(self.originalType().qName()) +
	'}\n' +
	'// End Observable stanza';
	
helper context ACCESSORSM!Attribute def : javaAdderNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (! this.' + self.name + '.contains(' + self.name + ')) {\n' +
	'    // Begin original body\n' +
	body +
	'\n    // End original body\n' +
	self.name.notifyStanza(self.originalType().qName()) +
	'}\n' +
	'// End Observable stanza';
	
helper context ACCESSORSM!Attribute def : javaRemoverNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (this.' + self.name + '.contains(' + self.name + ')) {\n' +
	'    // Begin original body\n' +
	body +
	'\n    // End original body\n' +
	self.name.notifyStanza(self.originalType().qName()) +
	'}\n' +
	'// End Observable stanza';

helper context String def : qClass() : ACCESSORSM!Class =
	ACCESSORSM!Class.allInstances()->select(c|c.qName()=self)->first();

helper context String def : mergeQClass() : MERGEMODEL!Class =
	MERGEMODEL!Class.allInstances()->select(c|c.qName()=self)->first();

helper context String def : hasQClass() : Boolean =
	not ACCESSORSM!Class.allInstances()->select(c|c.qName()=self)->isEmpty();

helper context String def : qInterface() : ACCESSORSM!Interface =
	ACCESSORSM!Interface.allInstances()->select(c|c.qName()=self)->first();

helper context String def : mergeQInterface() : MERGEMODEL!Interface =
	MERGEMODEL!Interface.allInstances()->select(c|c.qName()=self)->first();

helper context String def : hasQInterface() : Boolean =
	not ACCESSORSM!Interface.allInstances()->select(c|c.qName()=self)->isEmpty();

helper context String def : hasDataType() : Boolean =
	not ACCESSORSM!DataType.allInstances()->select(c|c.name=self)->isEmpty();

helper context String def : dataType() : ACCESSORSM!DataType =
	ACCESSORSM!DataType.allInstances()->select(c|c.name=self)->first();

helper context String def : mergeDataType() : MERGEMODEL!DataType =
	MERGEMODEL!DataType.allInstances()->select(c|c.name=self)->first();

helper context String def : hasStereotype() : Boolean =
	not ACCESSORSM!Stereotype.allInstances()->select(s|s.name=self)->isEmpty();

helper context String def : stereotype() : ACCESSORSM!Stereotype =
	ACCESSORSM!Stereotype.allInstances()->select(s|s.name=self)->first();

helper context String def : mergeStereotype() : MERGEMODEL!Stereotype =
	MERGEMODEL!Stereotype.allInstances()->select(s|s.name=self)->first();

helper context ACCESSORSM!AssociationEnd def : otherEnd() : ACCESSORSM!AssociationEnd =
	self.association.connection->select(x|x<>self)->first();

helper context ACCESSORSM!AssociationEnd def : navigableFrom() : ACCESSORSM!Classifier =
	self.otherEnd().participant;

helper context ACCESSORSM!Attribute def : hasAssociationEnd() : Boolean =
	not ACCESSORSM!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->isEmpty();

helper context ACCESSORSM!Attribute def : associationEnd() : ACCESSORSM!AssociationEnd =
	ACCESSORSM!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->first();

helper context ACCESSORSM!Attribute def : originalType() : ACCESSORSM!Classifier =
	if self.hasAssociationEnd() then
		self.associationEnd().participant
	else
		self.type
	endif;

helper context ACCESSORSM!Dependency def : isAccessorDependency() : Boolean =
	not self.stereotype->select(s|s.name='accessor')->isEmpty();
	
helper context ACCESSORSM!Operation def : isAccessor() : Boolean =
	not self.clientDependency->select(d|d.isAccessorDependency())->isEmpty();

helper context ACCESSORSM!Operation def : accessorDependency() : ACCESSORSM!Dependency =
	self.clientDependency->select(d|d.isAccessorDependency())->first();

helper context ACCESSORSM!Operation def : accessorFor() : ACCESSORSM!Attribute =
	self.accessorDependency().supplier->select(a|
		a.oclIsKindOf(ACCESSORSM!Attribute))->first();

helper context ACCESSORSM!Operation def : isSubscriber() : Boolean =
	if self.isAccessor() then
		self.accessorFor().hasSubscribesAssociation()
	else
		false
	endif;

helper context ACCESSORSM!Attribute def : hasSubscribesAssociation() : Boolean =
	if self.hasAssociationEnd() then
		not self.associationEnd().association.stereotype
			->select(s|s.name='subscribe')->isEmpty()
	else
		false
	endif;
	
helper context ACCESSORSM!GeneralizableElement def : isObservableType() : Boolean =
	not self.stereotype->select(s|s.name='Observable')->isEmpty();

helper context ACCESSORSM!GeneralizableElement def : isObservableKind() : Boolean =
	if self.isObservableType() then
		true
	else
		not self.generalization->select(g|g.parent.isObservableKind())->isEmpty()
	endif;

helper context ACCESSORSM!GeneralizableElement def : isObserverType() : Boolean =
	not self.stereotype->select(s|s.name='Observer')->isEmpty();

helper context ACCESSORSM!GeneralizableElement def : isObserverKind() : Boolean =
	if self.isObserverType() then
		true
	else
		not self.generalization->select(g|g.parent.isObserverKind())->isEmpty()
	endif;

helper context ACCESSORSM!ProcedureExpression def : method() : ACCESSORSM!Method =
	ACCESSORSM!Method.allInstances()->select(m|m.body=self)->first();

helper context ACCESSORSM!Operation def : javaNotify(body : String) : String =
	if self.name.stringStartsWith('remove') then
		self.accessorFor().javaRemoverNotify(body)
	else if self.name.stringStartsWith('add') or self.name.stringStartsWith('insert') then
		self.accessorFor().javaAdderNotify(body)
	else if self.name.stringStartsWith('set') then
		self.accessorFor().javaSetterNotify(body)
	else
		body
	endif endif endif;

helper context ACCESSORSM!Operation def : javaSubscribe(body : String) : String =
	if self.name.stringStartsWith('remove') then
		self.accessorFor().name.javaRemoverSubscribe(body)
	else if self.name.stringStartsWith('add') or self.name.stringStartsWith('insert') then
		self.accessorFor().name.javaAdderSubscribe(body)
	else if self.name.stringStartsWith('set') then
		self.accessorFor().name.javaSetterSubscribe(body)
	else
		body
	endif endif endif;

helper context ACCESSORSM!Classifier def : handlers() : Sequence(ACCESSORSM!Operation) =
	self.feature->select(f|
		if f.oclIsKindOf(ACCESSORSM!Operation) then
			f.name.stringStartsWith('on') and f.name.stringEndsWith('Change') and f.name.size() > 8
		else
			false
		endif
	);

helper context ACCESSORSM!Classifier def : updateBody() : String =
    self.handlers()->iterate(o; acc : String = ''|acc + o.updateBody('value'));

helper context ACCESSORSM!Operation def : updateBody(value : String) : String =
	'\nif (name.equals("' + self.propertyName() + '")) {\n' +
	'    ' + self.name + '(' + value.javaUnboxValue(self.parTypeName()) + ');\n' +
	'}';

helper context ACCESSORSM!Operation def : propertyName() : String =
	self.name.substring(3, self.name.size() - 6); -- onPropertyChange -> Property

helper context ACCESSORSM!Operation def : parTypeName() : String =
	self.parameter->first().type.qName();

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- non-mapsTo rules begin
-- ======================================================================

rule ObservableClass {
	from s : ACCESSORSM!Class (s.isObservableType())
	to observers : OBSERVERM!Attribute (
	   	name <- 'observers',
		owner <- s,
		type <- if 'java.util.Vector'.hasQClass()
			then 'java.util.Vector'.qClass()
			else 'java.util.Vector'.mergeQClass() endif,
		visibility <- #vk_private,
		ownerScope <- #sk_instance,
		changeability <- #ck_changeable,
		initialValue <- v),
	   v : OBSERVERM!Expression (
	   	language <- 'java',
		body <- 'new java.util.Vector()'),
	   addObserver : OBSERVERM!Operation (
	   	name <- 'addObserver',
		owner <- s,
		visibility <- #vk_public,
		ownerScope <- #sk_instance,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   addObserverPar : OBSERVERM!Parameter (
	   	name <- 'observer',
		behavioralFeature <- addObserver,
		type <- if 'observer.Observer'.hasQInterface()
			then 'observer.Observer'.qInterface()
			else 'observer.Observer'.mergeQInterface() endif,
		kind <- #pdk_in),
	   addObserverBody : OBSERVERM!ProcedureExpression (
	   	language <- 'java',
		body <- 'observers.addElement(observer);'),
	   addObserverMeth : OBSERVERM!Method (
	   	owner <- s,
		body <- addObserverBody,
		specification <- addObserver),
	   deleteObserver : OBSERVERM!Operation (
	   	name <- 'deleteObserver',
		owner <- s,
		visibility <- #vk_public,
		ownerScope <- #sk_instance,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   deleteObserverPar : OBSERVERM!Parameter (
	   	name <- 'observer',
		behavioralFeature <- deleteObserver,
		type <- if 'observer.Observer'.hasQInterface()
			then 'observer.Observer'.qInterface()
			else 'observer.Observer'.mergeQInterface() endif,
		kind <- #pdk_in),
	   deleteObserverBody : OBSERVERM!ProcedureExpression (
	   	language <- 'java',
		body <- 'observers.removeElement(observer);'),
	   deleteObserverMeth : OBSERVERM!Method (
	   	owner <- s,
		body <- deleteObserverBody,
		specification <- deleteObserver),
	   notifyObservers : OBSERVERM!Operation (
	   	name <- 'notifyObservers',
		owner <- s,
		visibility <- #vk_protected,
		ownerScope <- #sk_instance,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   notifyObserversName : OBSERVERM!Parameter (
	   	name <- 'name',
		behavioralFeature <- notifyObservers,
		type <- if 'String'.hasDataType()
			then 'String'.dataType()
			else 'String'.mergeDataType() endif,
		kind <- #pdk_in),
	   notifyObserversValue : OBSERVERM!Parameter (
	   	name <- 'value',
		behavioralFeature <- notifyObservers,
		type <- if 'OclAny'.hasDataType()
			then 'OclAny'.dataType()
			else 'OclAny'.mergeDataType() endif,
		kind <- #pdk_in),
	   notifyObserversBody : OBSERVERM!ProcedureExpression (
	   	language <- 'java',
		body <- 'name, value'.javaNotifyObservers()),
	   notifyObserversMeth : OBSERVERM!Method (
	   	owner <- s,
		body <- notifyObserversBody,
		specification <- notifyObservers)
}

rule ObserverClass {
	from s : ACCESSORSM!Class (s.isObserverType())
	to t : OBSERVERM!Abstraction (
	   	namespace <- s.namespace,
		stereotype <- if 'realize'.hasStereotype()
			then 'realize'.stereotype()
			else 'realize'.mergeStereotype() endif,
		supplier <- Set{if 'observer.Observer'.hasQInterface()
			then 'observer.Observer'.qInterface()
			else 'observer.Observer'.mergeQInterface() endif},
		client <- Set{s}),
	   op : OBSERVERM!Operation (
	   	name <- 'update',
		owner <- s,
		visibility <- #vk_public,
		ownerScope <- #sk_instance,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   name : OBSERVERM!Parameter (
	   	name <- 'name',
		behavioralFeature <- op,
		type <- if 'String'.hasDataType()
			then 'String'.dataType()
			else 'String'.mergeDataType() endif,
		kind <- #pdk_in),
	   value : OBSERVERM!Parameter (
	   	name <- 'value',
		behavioralFeature <- op,
		type <- if 'OclAny'.hasDataType()
			then 'OclAny'.dataType()
			else 'OclAny'.mergeDataType() endif,
		kind <- #pdk_in),
	   mbody : OBSERVERM!ProcedureExpression (
	   	language <- 'java',
		body <- s.updateBody()),
	   meth : OBSERVERM!Method (
	   	owner <- s,
		body <- mbody,
		specification <- op)
}

-- ======================================================================
-- non-mapsTo rules end
-- ======================================================================

-- ======================================================================
-- mapsTo rules begin
-- ======================================================================

rule ProcedureExpression {
	from s : ACCESSORSM!ProcedureExpression (not (
		 s.method().specification.isAccessor() and
		 (s.method().owner.isObservableKind() or
		  (s.method().owner.isObserverKind() and
		   s.method().specification.isSubscriber()))))
	to t : OBSERVERM!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.body)
}

rule NotifyProcedureExpression {
	from s : ACCESSORSM!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 s.method().owner.isObservableKind() and
		 not (s.method().owner.isObserverKind() and
		      s.method().specification.isSubscriber()))
	to t : OBSERVERM!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaNotify(s.body))
}

rule NotifySubscribeProcedureExpression {
	from s : ACCESSORSM!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 s.method().owner.isObservableKind() and
		 s.method().owner.isObserverKind() and
		 s.method().specification.isSubscriber())
	to t : OBSERVERM!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaNotify(
			s.method().specification.javaSubscribe(s.body)))
}

rule SubscribeProcedureExpression {
	from s : ACCESSORSM!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 not s.method().owner.isObservableKind() and
		 s.method().owner.isObserverKind() and
		 s.method().specification.isSubscriber())
	to t : OBSERVERM!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaSubscribe(s.body))
}

-- ======================================================================
-- mapsTo rules end
-- ======================================================================

-- ======================================================================
-- model merge begin
-- ======================================================================
-- From: ModelMerge.atl 1174 2005-05-23 07:38:38Z dwagelaa

rule MergeAssociation {
    from s : MERGEMODEL!Association (s.oclIsTypeOf(MERGEMODEL!Association) and
    	s.notInSourceModel())
    to t : OBSERVERM!Association mapsTo s (
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        connection <- s.connection,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeTaggedValue {
    from s : MERGEMODEL!TaggedValue (s.notInSourceModel())
    to t : OBSERVERM!TaggedValue mapsTo s (
        dataValue <- s.dataValue,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        referenceValue <- s.referenceValue,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        type <- if s.type.notInSourceModel()
			then s.type
			else s.type.fromSourceModel() endif)
}

rule MergeOperation {
    from s : MERGEMODEL!Operation (s.notInSourceModel())
    to t : OBSERVERM!Operation mapsTo s (
        ownerScope <- s.ownerScope,
        visibility <- s.visibility,
        isQuery <- s.isQuery,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        specification <- s.specification,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MergeProcedureExpression {
    from s : MERGEMODEL!ProcedureExpression (s.notInSourceModel())
    to t : OBSERVERM!ProcedureExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule MergeAbstraction {
    from s : MERGEMODEL!Abstraction (s.notInSourceModel())
    to t : OBSERVERM!Abstraction mapsTo s (
        mapping <- s.mapping,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        client <- s.client->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        supplier <- s.supplier->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeMultiplicity {
    from s : MERGEMODEL!Multiplicity (s.notInSourceModel())
    to t : OBSERVERM!Multiplicity mapsTo s (
        range <- s.range)
}

rule MergeParameter {
    from s : MERGEMODEL!Parameter (s.notInSourceModel())
    to t : OBSERVERM!Parameter mapsTo s (
        kind <- s.kind,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        defaultValue <- s.defaultValue,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        type <- if s.type.notInSourceModel()
			then s.type
			else s.type.fromSourceModel() endif,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MergeClass {
    from s : MERGEMODEL!Class (s.oclIsTypeOf(MERGEMODEL!Class) and
    	s.notInSourceModel())
    to t : OBSERVERM!Class mapsTo s (
        isRoot <- s.isRoot,
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        powertypeRange <- s.powertypeRange,
        feature <- s.feature,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeInterface {
    from s : MERGEMODEL!Interface (s.notInSourceModel())
    to t : OBSERVERM!Interface mapsTo s (
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        powertypeRange <- s.powertypeRange,
        feature <- s.feature,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeMultiplicityRange {
    from s : MERGEMODEL!MultiplicityRange (s.notInSourceModel())
    to t : OBSERVERM!MultiplicityRange mapsTo s (
        upper <- s.upper,
        lower <- s.lower)
}

rule MergeExpression {
    from s : MERGEMODEL!Expression (s.oclIsTypeOf(MERGEMODEL!Expression) and
    	s.notInSourceModel())
    to t : OBSERVERM!Expression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule MergeDataType {
    from s : MERGEMODEL!DataType (s.oclIsTypeOf(MERGEMODEL!DataType) and
    	s.notInSourceModel())
    to t : OBSERVERM!DataType mapsTo s (
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        powertypeRange <- s.powertypeRange,
        feature <- s.feature,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergePackage {
    from s : MERGEMODEL!Package (s.oclIsTypeOf(MERGEMODEL!Package) and
    	s.notInSourceModel())
    to t : OBSERVERM!Package mapsTo s (
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        elementImport <- s.elementImport,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeAssociationEnd {
    from s : MERGEMODEL!AssociationEnd (s.oclIsTypeOf(MERGEMODEL!AssociationEnd) and
    	s.notInSourceModel())
    to t : OBSERVERM!AssociationEnd mapsTo s (
        targetScope <- s.targetScope,
        isNavigable <- s.isNavigable,
        ordering <- s.ordering,
        changeability <- s.changeability,
        multiplicity <- s.multiplicity,
        aggregation <- s.aggregation,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        qualifier <- s.qualifier,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        participant <- if s.participant.notInSourceModel()
			then s.participant
			else s.participant.fromSourceModel() endif,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        constraint <- s.constraint,
        specification <- s.specification,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MergeAttribute {
    from s : MERGEMODEL!Attribute (s.notInSourceModel())
    to t : OBSERVERM!Attribute mapsTo s (
        targetScope <- s.targetScope,
        initialValue <- s.initialValue,
        ownerScope <- s.ownerScope,
        visibility <- s.visibility,
        changeability <- s.changeability,
        ordering <- s.ordering,
        name <- s.name,
        isSpecification <- s.isSpecification,
        multiplicity <- s.multiplicity,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        type <- if s.type.notInSourceModel()
			then s.type
			else s.type.fromSourceModel() endif,
        sourceFlow <- s.sourceFlow)
}

rule MergeGeneralization {
    from s : MERGEMODEL!Generalization (s.notInSourceModel())
    to t : OBSERVERM!Generalization mapsTo s (
        discriminator <- s.discriminator,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        powertype <- s.powertype,
        parent <- if s.parent.notInSourceModel()
			then s.parent
			else s.parent.fromSourceModel() endif,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        child <- if s.child.notInSourceModel()
			then s.child
			else s.child.fromSourceModel() endif,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeDependency {
    from s : MERGEMODEL!Dependency (s.oclIsTypeOf(MERGEMODEL!Dependency) and
    	s.notInSourceModel())
    to t : OBSERVERM!Dependency mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        client <- s.client->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        supplier <- s.supplier->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeTagDefinition {
    from s : MERGEMODEL!TagDefinition (s.notInSourceModel())
    to t : OBSERVERM!TagDefinition mapsTo s (
        tagType <- s.tagType,
        multiplicity <- s.multiplicity,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeStereotype {
    from s : MERGEMODEL!Stereotype (s.notInSourceModel())
    to t : OBSERVERM!Stereotype mapsTo s (
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        baseClass <- s.baseClass,
        visibility <- s.visibility,
        name <- s.name,
        icon <- s.icon,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        templateParameter <- s.templateParameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        generalization <- s.generalization,
        comment <- s.comment,
        definedTag <- s.definedTag,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotypeConstraint <- s.stereotypeConstraint,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

rule MergeMethod {
    from s : MERGEMODEL!Method (s.notInSourceModel())
    to t : OBSERVERM!Method mapsTo s (
        body <- s.body,
        ownerScope <- s.ownerScope,
        visibility <- s.visibility,
        isQuery <- s.isQuery,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        comment <- s.comment,
        specification <- s.specification,
        constraint <- s.constraint,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MergeException {
    from s : MERGEMODEL!Exception (s.notInSourceModel())
    to t : OBSERVERM!Exception mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        "context" <- s."context",
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype->collect(e|if e.notInSourceModel()
        	then e else e.fromSourceModel() endif),
        generalization <- s.generalization,
        comment <- s.comment,
		namespace <- if s.namespace.notInSourceModel()
			then s.namespace
			else s.namespace.fromSourceModel() endif)
}

-- ======================================================================
-- model merge end
-- ======================================================================

-- ======================================================================
-- model copy begin
-- ======================================================================
-- Generated by: ModelCopyGenerator.atl 1101 2005-05-12 10:35:43Z dwagelaa

rule Generalization {
    from s : ACCESSORSM!Generalization
    to t : OBSERVERM!Generalization mapsTo s (
        discriminator <- s.discriminator,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        child <- s.child,
        constraint <- s.constraint,
        parent <- s.parent,
        stereotype <- s.stereotype,
        powertype <- s.powertype,
        comment <- s.comment)
}

rule Abstraction {
    from s : ACCESSORSM!Abstraction
    to t : OBSERVERM!Abstraction mapsTo s (
        name <- s.name,
        mapping <- s.mapping,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        supplier <- s.supplier,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        client <- s.client,
        comment <- s.comment)
}

rule InteractionInstanceSet {
    from s : ACCESSORSM!InteractionInstanceSet
    to t : OBSERVERM!InteractionInstanceSet mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        participatingStimulus <- s.participatingStimulus,
        interaction <- s.interaction)
}

rule Operation {
    from s : ACCESSORSM!Operation
    to t : OBSERVERM!Operation mapsTo s (
        ownerScope <- s.ownerScope,
        isQuery <- s.isQuery,
        specification <- s.specification,
        isLeaf <- s.isLeaf,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRoot <- s.isRoot,
        concurrency <- s.concurrency,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment)
}

rule Association {
    from s : ACCESSORSM!Association (s.oclIsTypeOf(ACCESSORSM!Association))
    to t : OBSERVERM!Association mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        connection <- s.connection,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Exception {
    from s : ACCESSORSM!Exception
    to t : OBSERVERM!Exception mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        "context" <- s."context",
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Interface {
    from s : ACCESSORSM!Interface
    to t : OBSERVERM!Interface mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule UseCase {
    from s : ACCESSORSM!UseCase
    to t : OBSERVERM!UseCase mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        extensionPoint <- s.extensionPoint,
        powertypeRange <- s.powertypeRange,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment,
        extend <- s.extend,
        include <- s.include)
}

rule Argument {
    from s : ACCESSORSM!Argument
    to t : OBSERVERM!Argument mapsTo s (
        value <- s.value,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment)
}

rule TaggedValue {
    from s : ACCESSORSM!TaggedValue
    to t : OBSERVERM!TaggedValue mapsTo s (
        dataValue <- s.dataValue,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        referenceValue <- s.referenceValue,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        type <- s.type)
}

rule ReturnAction {
    from s : ACCESSORSM!ReturnAction
    to t : OBSERVERM!ReturnAction mapsTo s (
        recurrence <- s.recurrence,
        name <- s.name,
        target <- s.target,
        script <- s.script,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        actualArgument <- s.actualArgument)
}

rule Expression {
    from s : ACCESSORSM!Expression (s.oclIsTypeOf(ACCESSORSM!Expression))
    to t : OBSERVERM!Expression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule CallAction {
    from s : ACCESSORSM!CallAction
    to t : OBSERVERM!CallAction mapsTo s (
        recurrence <- s.recurrence,
        name <- s.name,
        target <- s.target,
        script <- s.script,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        operation <- s.operation,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        actualArgument <- s.actualArgument)
}

rule AssociationEnd {
    from s : ACCESSORSM!AssociationEnd (s.oclIsTypeOf(ACCESSORSM!AssociationEnd))
    to t : OBSERVERM!AssociationEnd mapsTo s (
        targetScope <- s.targetScope,
        isNavigable <- s.isNavigable,
        name <- s.name,
        aggregation <- s.aggregation,
        changeability <- s.changeability,
        ordering <- s.ordering,
        visibility <- s.visibility,
        multiplicity <- s.multiplicity,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        participant <- s.participant,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        specification <- s.specification,
        qualifier <- s.qualifier)
}

rule Dependency {
    from s : ACCESSORSM!Dependency (s.oclIsTypeOf(ACCESSORSM!Dependency))
    to t : OBSERVERM!Dependency mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        supplier <- s.supplier,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        client <- s.client,
        comment <- s.comment)
}

rule Package {
    from s : ACCESSORSM!Package (s.oclIsTypeOf(ACCESSORSM!Package))
    to t : OBSERVERM!Package mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        elementImport <- s.elementImport,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule TagDefinition {
    from s : ACCESSORSM!TagDefinition
    to t : OBSERVERM!TagDefinition mapsTo s (
        multiplicity <- s.multiplicity,
        name <- s.name,
        tagType <- s.tagType,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment)
}

rule Method {
    from s : ACCESSORSM!Method
    to t : OBSERVERM!Method mapsTo s (
        ownerScope <- s.ownerScope,
        isQuery <- s.isQuery,
        name <- s.name,
        body <- s.body,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        specification <- s.specification,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment)
}

rule MultiplicityRange {
    from s : ACCESSORSM!MultiplicityRange
    to t : OBSERVERM!MultiplicityRange mapsTo s (
        lower <- s.lower,
        upper <- s.upper)
}

rule LinkEnd {
    from s : ACCESSORSM!LinkEnd
    to t : OBSERVERM!LinkEnd mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        associationEnd <- s.associationEnd,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        instance <- s.instance,
        stereotype <- s.stereotype,
        comment <- s.comment,
        qualifiedValue <- s.qualifiedValue)
}

rule CollaborationInstanceSet {
    from s : ACCESSORSM!CollaborationInstanceSet
    to t : OBSERVERM!CollaborationInstanceSet mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        participatingLink <- s.participatingLink,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        participatingInstance <- s.participatingInstance,
        templateParameter <- s.templateParameter,
        interactionInstanceSet <- s.interactionInstanceSet,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        constrainingElement <- s.constrainingElement,
        comment <- s.comment,
        collaboration <- s.collaboration)
}

rule Stimulus {
    from s : ACCESSORSM!Stimulus
    to t : OBSERVERM!Stimulus mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        sender <- s.sender,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        communicationLink <- s.communicationLink,
        dispatchAction <- s.dispatchAction,
        comment <- s.comment,
        argument <- s.argument,
        receiver <- s.receiver)
}

rule Link {
    from s : ACCESSORSM!Link (s.oclIsTypeOf(ACCESSORSM!Link))
    to t : OBSERVERM!Link mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        association <- s.association,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment)
}

rule Model {
    from s : ACCESSORSM!Model
    to t : OBSERVERM!Model mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        elementImport <- s.elementImport,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Object {
    from s : ACCESSORSM!Object (s.oclIsTypeOf(ACCESSORSM!Object))
    to t : OBSERVERM!Object mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        ownedInstance <- s.ownedInstance,
        sourceFlow <- s.sourceFlow,
        ownedLink <- s.ownedLink,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        componentInstance <- s.componentInstance,
        linkEnd <- s.linkEnd,
        stereotype <- s.stereotype,
        comment <- s.comment,
        slot <- s.slot)
}

rule Attribute {
    from s : ACCESSORSM!Attribute
    to t : OBSERVERM!Attribute mapsTo s (
        ownerScope <- s.ownerScope,
        initialValue <- s.initialValue,
        name <- s.name,
        targetScope <- s.targetScope,
        multiplicity <- s.multiplicity,
        changeability <- s.changeability,
        ordering <- s.ordering,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        type <- s.type)
}

rule Class {
    from s : ACCESSORSM!Class (s.oclIsTypeOf(ACCESSORSM!Class))
    to t : OBSERVERM!Class mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Parameter {
    from s : ACCESSORSM!Parameter
    to t : OBSERVERM!Parameter mapsTo s (
        name <- s.name,
        kind <- s.kind,
        defaultValue <- s.defaultValue,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        type <- s.type)
}

rule Message {
    from s : ACCESSORSM!Message
    to t : OBSERVERM!Message mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        action <- s.action,
        activator <- s.activator,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        receiver <- s.receiver,
        sender <- s.sender,
        predecessor <- s.predecessor,
        templateParameter <- s.templateParameter,
        conformingStimulus <- s.conformingStimulus,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        communicationConnection <- s.communicationConnection)
}

rule Stereotype {
    from s : ACCESSORSM!Stereotype
    to t : OBSERVERM!Stereotype mapsTo s (
        isRoot <- s.isRoot,
        icon <- s.icon,
        name <- s.name,
        baseClass <- s.baseClass,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        stereotypeConstraint <- s.stereotypeConstraint,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        definedTag <- s.definedTag,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Collaboration {
    from s : ACCESSORSM!Collaboration
    to t : OBSERVERM!Collaboration mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        usedCollaboration <- s.usedCollaboration,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        interaction <- s.interaction,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        constrainingElement <- s.constrainingElement,
        representedClassifier <- s.representedClassifier,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment,
        representedOperation <- s.representedOperation)
}

rule DataType {
    from s : ACCESSORSM!DataType (s.oclIsTypeOf(ACCESSORSM!DataType))
    to t : OBSERVERM!DataType mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

rule Multiplicity {
    from s : ACCESSORSM!Multiplicity
    to t : OBSERVERM!Multiplicity mapsTo s (
        range <- s.range)
}

rule Include {
    from s : ACCESSORSM!Include
    to t : OBSERVERM!Include mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        templateParameter <- s.templateParameter,
        base <- s.base,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        comment <- s.comment,
        addition <- s.addition)
}

rule Actor {
    from s : ACCESSORSM!Actor
    to t : OBSERVERM!Actor mapsTo s (
        isRoot <- s.isRoot,
        name <- s.name,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        targetFlow <- s.targetFlow,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        ownedElement <- s.ownedElement,
        templateParameter <- s.templateParameter,
        constraint <- s.constraint,
        feature <- s.feature,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        comment <- s.comment)
}

-- ======================================================================
-- model copy end
-- ======================================================================
