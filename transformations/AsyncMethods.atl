-- $Id$
module AsyncMethods;

create ASYNC : ASYNCM from DATATYPES : DATATYPESM;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context DATATYPESM!ProcedureExpression def : method() : DATATYPESM!Method =
	DATATYPESM!Method.allInstances()->select(m|m.body=self)->first();

helper context DATATYPESM!Operation def : isAsynchronous() : Boolean =
	not self.stereotype->select(s|s.name='asynchronous')->isEmpty();

helper context String def : asynchronous() : String =
	'Thread t = new Thread() {\n' +
	'    public void run() {\n' +
	self + '\n' +
	'    }\n' +
	'};\n' +
	't.start();';

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- mapsTo rules begin
-- ======================================================================

rule ProcedureExpression {
    from s : DATATYPESM!ProcedureExpression (not
    	s.method().specification.isAsynchronous())
    to t : ASYNCM!ProcedureExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule AsyncProcedureExpression {
    from s : DATATYPESM!ProcedureExpression (
    	s.method().specification.isAsynchronous())
    to t : ASYNCM!ProcedureExpression mapsTo s (
        body <- s.body.asynchronous(),
        language <- s.language)
}

-- ======================================================================
-- mapsTo rules end
-- ======================================================================

-- ======================================================================
-- model copy begin
-- ======================================================================
-- Generated by: ModelCopyGenerator.atl 1515 2005-06-15 14:41:07Z dwagelaa $

rule UseCase {
    from s : DATATYPESM!UseCase
    to t : ASYNCM!UseCase mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        feature <- s.feature,
        extend <- s.extend,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        include <- s.include,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        extensionPoint <- s.extensionPoint,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule AssociationEnd {
    from s : DATATYPESM!AssociationEnd (s.oclIsTypeOf(DATATYPESM!AssociationEnd))
    to t : ASYNCM!AssociationEnd mapsTo s (
        multiplicity <- s.multiplicity,
        aggregation <- s.aggregation,
        visibility <- s.visibility,
        targetScope <- s.targetScope,
        changeability <- s.changeability,
        name <- s.name,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        isNavigable <- s.isNavigable,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        qualifier <- s.qualifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        specification <- s.specification,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        participant <- s.participant,
        sourceFlow <- s.sourceFlow)
}

rule Actor {
    from s : DATATYPESM!Actor
    to t : ASYNCM!Actor mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        feature <- s.feature,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Interface {
    from s : DATATYPESM!Interface
    to t : ASYNCM!Interface mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        feature <- s.feature,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Stereotype {
    from s : DATATYPESM!Stereotype
    to t : ASYNCM!Stereotype mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        baseClass <- s.baseClass,
        icon <- s.icon,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        stereotypeConstraint <- s.stereotypeConstraint,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        definedTag <- s.definedTag,
        sourceFlow <- s.sourceFlow)
}

rule Dependency {
    from s : DATATYPESM!Dependency (s.oclIsTypeOf(DATATYPESM!Dependency))
    to t : ASYNCM!Dependency mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        client <- s.client,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow)
}

rule Association {
    from s : DATATYPESM!Association (s.oclIsTypeOf(DATATYPESM!Association))
    to t : ASYNCM!Association mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        connection <- s.connection,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Collaboration {
    from s : DATATYPESM!Collaboration
    to t : ASYNCM!Collaboration mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        representedOperation <- s.representedOperation,
        constrainingElement <- s.constrainingElement,
        usedCollaboration <- s.usedCollaboration,
        representedClassifier <- s.representedClassifier,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow,
        interaction <- s.interaction)
}

rule Message {
    from s : DATATYPESM!Message
    to t : ASYNCM!Message mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        conformingStimulus <- s.conformingStimulus,
        comment <- s.comment,
        action <- s.action,
        receiver <- s.receiver,
        sender <- s.sender,
        taggedValue <- s.taggedValue,
        predecessor <- s.predecessor,
        clientDependency <- s.clientDependency,
        communicationConnection <- s.communicationConnection,
        activator <- s.activator,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Include {
    from s : DATATYPESM!Include
    to t : ASYNCM!Include mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        base <- s.base,
        clientDependency <- s.clientDependency,
        addition <- s.addition,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule DataType {
    from s : DATATYPESM!DataType (s.oclIsTypeOf(DATATYPESM!DataType))
    to t : ASYNCM!DataType mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        feature <- s.feature,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Operation {
    from s : DATATYPESM!Operation
    to t : ASYNCM!Operation mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        specification <- s.specification,
        name <- s.name,
        isQuery <- s.isQuery,
        isSpecification <- s.isSpecification,
        ownerScope <- s.ownerScope,
        concurrency <- s.concurrency,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule CollaborationInstanceSet {
    from s : DATATYPESM!CollaborationInstanceSet
    to t : ASYNCM!CollaborationInstanceSet mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        interactionInstanceSet <- s.interactionInstanceSet,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        participatingLink <- s.participatingLink,
        collaboration <- s.collaboration,
        constrainingElement <- s.constrainingElement,
        taggedValue <- s.taggedValue,
        participatingInstance <- s.participatingInstance,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Parameter {
    from s : DATATYPESM!Parameter
    to t : ASYNCM!Parameter mapsTo s (
        visibility <- s.visibility,
        kind <- s.kind,
        defaultValue <- s.defaultValue,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        type <- s.type,
        sourceFlow <- s.sourceFlow)
}

rule Pseudostate {
    from s : DATATYPESM!Pseudostate
    to t : ASYNCM!Pseudostate mapsTo s (
        visibility <- s.visibility,
        kind <- s.kind,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        outgoing <- s.outgoing,
        sourceFlow <- s.sourceFlow)
}

rule Class {
    from s : DATATYPESM!Class (s.oclIsTypeOf(DATATYPESM!Class))
    to t : ASYNCM!Class mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        feature <- s.feature,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Expression {
    from s : DATATYPESM!Expression (s.oclIsTypeOf(DATATYPESM!Expression))
    to t : ASYNCM!Expression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule CallEvent {
    from s : DATATYPESM!CallEvent
    to t : ASYNCM!CallEvent mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        operation <- s.operation,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule MultiplicityRange {
    from s : DATATYPESM!MultiplicityRange
    to t : ASYNCM!MultiplicityRange mapsTo s (
        upper <- s.upper,
        lower <- s.lower)
}

rule StateMachine {
    from s : DATATYPESM!StateMachine (s.oclIsTypeOf(DATATYPESM!StateMachine))
    to t : ASYNCM!StateMachine mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        submachineState <- s.submachineState,
        comment <- s.comment,
        top <- s.top,
        taggedValue <- s.taggedValue,
        transitions <- s.transitions,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule CallAction {
    from s : DATATYPESM!CallAction
    to t : ASYNCM!CallAction mapsTo s (
        script <- s.script,
        target <- s.target,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        actualArgument <- s.actualArgument,
        operation <- s.operation,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Package {
    from s : DATATYPESM!Package (s.oclIsTypeOf(DATATYPESM!Package))
    to t : ASYNCM!Package mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        elementImport <- s.elementImport,
        comment <- s.comment,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Abstraction {
    from s : DATATYPESM!Abstraction
    to t : ASYNCM!Abstraction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        mapping <- s.mapping,
        templateParameter <- s.templateParameter,
        client <- s.client,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow)
}

rule BooleanExpression {
    from s : DATATYPESM!BooleanExpression
    to t : ASYNCM!BooleanExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule ReturnAction {
    from s : DATATYPESM!ReturnAction
    to t : ASYNCM!ReturnAction mapsTo s (
        script <- s.script,
        target <- s.target,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Argument {
    from s : DATATYPESM!Argument
    to t : ASYNCM!Argument mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        value <- s.value,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule InteractionInstanceSet {
    from s : DATATYPESM!InteractionInstanceSet
    to t : ASYNCM!InteractionInstanceSet mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        interaction <- s.interaction,
        clientDependency <- s.clientDependency,
        participatingStimulus <- s.participatingStimulus,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule LinkEnd {
    from s : DATATYPESM!LinkEnd
    to t : ASYNCM!LinkEnd mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        instance <- s.instance,
        taggedValue <- s.taggedValue,
        qualifiedValue <- s.qualifiedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        associationEnd <- s.associationEnd,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule TaggedValue {
    from s : DATATYPESM!TaggedValue
    to t : ASYNCM!TaggedValue mapsTo s (
        dataValue <- s.dataValue,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        type <- s.type,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        referenceValue <- s.referenceValue,
        sourceFlow <- s.sourceFlow)
}

rule SimpleState {
    from s : DATATYPESM!SimpleState (s.oclIsTypeOf(DATATYPESM!SimpleState))
    to t : ASYNCM!SimpleState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        entry <- s.entry,
        deferrableEvent <- s.deferrableEvent,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        exit <- s.exit,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        outgoing <- s.outgoing,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow)
}

rule Generalization {
    from s : DATATYPESM!Generalization
    to t : ASYNCM!Generalization mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        discriminator <- s.discriminator,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        child <- s.child,
        taggedValue <- s.taggedValue,
        powertype <- s.powertype,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        parent <- s.parent,
        sourceFlow <- s.sourceFlow)
}

rule Multiplicity {
    from s : DATATYPESM!Multiplicity
    to t : ASYNCM!Multiplicity mapsTo s (
        range <- s.range)
}

rule Object {
    from s : DATATYPESM!Object (s.oclIsTypeOf(DATATYPESM!Object))
    to t : ASYNCM!Object mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        ownedLink <- s.ownedLink,
        classifier <- s.classifier,
        slot <- s.slot,
        taggedValue <- s.taggedValue,
        linkEnd <- s.linkEnd,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        ownedInstance <- s.ownedInstance,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        sourceFlow <- s.sourceFlow)
}

rule TagDefinition {
    from s : DATATYPESM!TagDefinition
    to t : ASYNCM!TagDefinition mapsTo s (
        multiplicity <- s.multiplicity,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        tagType <- s.tagType,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Model {
    from s : DATATYPESM!Model
    to t : ASYNCM!Model mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        elementImport <- s.elementImport,
        comment <- s.comment,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Exception {
    from s : DATATYPESM!Exception
    to t : ASYNCM!Exception mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isAbstract <- s.isAbstract,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        "context" <- s."context",
        feature <- s.feature,
        ownedElement <- s.ownedElement,
        taggedValue <- s.taggedValue,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        generalization <- s.generalization,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Transition {
    from s : DATATYPESM!Transition
    to t : ASYNCM!Transition mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        guard <- s.guard,
        comment <- s.comment,
        trigger <- s.trigger,
        target <- s.target,
        effect <- s.effect,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        source <- s.source,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Link {
    from s : DATATYPESM!Link (s.oclIsTypeOf(DATATYPESM!Link))
    to t : ASYNCM!Link mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        association <- s.association,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        connection <- s.connection,
        sourceFlow <- s.sourceFlow)
}

rule CompositeState {
    from s : DATATYPESM!CompositeState (s.oclIsTypeOf(DATATYPESM!CompositeState))
    to t : ASYNCM!CompositeState mapsTo s (
        isConcurrent <- s.isConcurrent,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        entry <- s.entry,
        deferrableEvent <- s.deferrableEvent,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        exit <- s.exit,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        subvertex <- s.subvertex,
        outgoing <- s.outgoing,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow)
}

rule Attribute {
    from s : DATATYPESM!Attribute
    to t : ASYNCM!Attribute mapsTo s (
        ordering <- s.ordering,
        initialValue <- s.initialValue,
        changeability <- s.changeability,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        ownerScope <- s.ownerScope,
        multiplicity <- s.multiplicity,
        targetScope <- s.targetScope,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        type <- s.type,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Stimulus {
    from s : DATATYPESM!Stimulus
    to t : ASYNCM!Stimulus mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        receiver <- s.receiver,
        sender <- s.sender,
        taggedValue <- s.taggedValue,
        dispatchAction <- s.dispatchAction,
        communicationLink <- s.communicationLink,
        clientDependency <- s.clientDependency,
        argument <- s.argument,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Guard {
    from s : DATATYPESM!Guard
    to t : ASYNCM!Guard mapsTo s (
        expression <- s.expression,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

rule Method {
    from s : DATATYPESM!Method
    to t : ASYNCM!Method mapsTo s (
        body <- s.body,
        visibility <- s.visibility,
        name <- s.name,
        isQuery <- s.isQuery,
        isSpecification <- s.isSpecification,
        ownerScope <- s.ownerScope,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        comment <- s.comment,
        taggedValue <- s.taggedValue,
        specification <- s.specification,
        clientDependency <- s.clientDependency,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        stereotype <- s.stereotype,
        sourceFlow <- s.sourceFlow)
}

-- ======================================================================
-- model copy end
-- ======================================================================
