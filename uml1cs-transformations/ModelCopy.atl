-- Generated by: $Id: ModelCopyGenerator.atl 3143 2006-01-13 13:36:01Z dwagelaa $
module ModelCopy;

create OUT : OUTMODEL from IN : INMODEL;

rule TagDefinition {
    from s : INMODEL!TagDefinition
    to t : OUTMODEL!TagDefinition mapsTo s (
        multiplicity <- s.multiplicity,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        tagType <- s.tagType,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Dependency {
    from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
    to t : OUTMODEL!Dependency mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        client <- s.client,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ClassifierInState {
    from s : INMODEL!ClassifierInState
    to t : OUTMODEL!ClassifierInState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        type <- s.type,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        inState <- s.inState,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule Stimulus {
    from s : INMODEL!Stimulus
    to t : OUTMODEL!Stimulus mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        receiver <- s.receiver,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        communicationLink <- s.communicationLink,
        templateParameter <- s.templateParameter,
        sender <- s.sender,
        argument <- s.argument,
        dispatchAction <- s.dispatchAction,
        clientDependency <- s.clientDependency)
}

rule Transition {
    from s : INMODEL!Transition
    to t : OUTMODEL!Transition mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        source <- s.source,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        trigger <- s.trigger,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        guard <- s.guard,
        effect <- s.effect,
        target <- s.target,
        clientDependency <- s.clientDependency)
}

rule Stereotype {
    from s : INMODEL!Stereotype
    to t : OUTMODEL!Stereotype mapsTo s (
        baseClass <- s.baseClass,
        isSpecification <- s.isSpecification,
        icon <- s.icon,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        definedTag <- s.definedTag,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        generalization <- s.generalization,
        clientDependency <- s.clientDependency,
        stereotypeConstraint <- s.stereotypeConstraint)
}

rule ChangeEvent {
    from s : INMODEL!ChangeEvent
    to t : OUTMODEL!ChangeEvent mapsTo s (
        changeExpression <- s.changeExpression,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Abstraction {
    from s : INMODEL!Abstraction
    to t : OUTMODEL!Abstraction mapsTo s (
        isSpecification <- s.isSpecification,
        mapping <- s.mapping,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        client <- s.client,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ActivityGraph {
    from s : INMODEL!ActivityGraph
    to t : OUTMODEL!ActivityGraph mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        partition <- s.partition,
        taggedValue <- s.taggedValue,
        transitions <- s.transitions,
        sourceFlow <- s.sourceFlow,
        top <- s.top,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        submachineState <- s.submachineState,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Generalization {
    from s : INMODEL!Generalization
    to t : OUTMODEL!Generalization mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        discriminator <- s.discriminator,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        powertype <- s.powertype,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        child <- s.child,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        parent <- s.parent,
        clientDependency <- s.clientDependency)
}

rule TemplateArgument {
    from s : INMODEL!TemplateArgument
    to t : OUTMODEL!TemplateArgument mapsTo s (
        modelElement <- s.modelElement)
}

rule TypeExpression {
    from s : INMODEL!TypeExpression
    to t : OUTMODEL!TypeExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule UseCaseInstance {
    from s : INMODEL!UseCaseInstance
    to t : OUTMODEL!UseCaseInstance mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Artifact {
    from s : INMODEL!Artifact
    to t : OUTMODEL!Artifact mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule CallAction {
    from s : INMODEL!CallAction
    to t : OUTMODEL!CallAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        operation <- s.operation,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule DataValue {
    from s : INMODEL!DataValue
    to t : OUTMODEL!DataValue mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Message {
    from s : INMODEL!Message
    to t : OUTMODEL!Message mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        communicationConnection <- s.communicationConnection,
        conformingStimulus <- s.conformingStimulus,
        taggedValue <- s.taggedValue,
        predecessor <- s.predecessor,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        activator <- s.activator,
        comment <- s.comment,
        action <- s.action,
        templateParameter <- s.templateParameter,
        sender <- s.sender,
        receiver <- s.receiver,
        clientDependency <- s.clientDependency)
}

rule Usage {
    from s : INMODEL!Usage
    to t : OUTMODEL!Usage mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        client <- s.client,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ArgListsExpression {
    from s : INMODEL!ArgListsExpression
    to t : OUTMODEL!ArgListsExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule Component {
    from s : INMODEL!Component
    to t : OUTMODEL!Component mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        implementation <- s.implementation,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        residentElement <- s.residentElement,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule ObjectSetExpression {
    from s : INMODEL!ObjectSetExpression
    to t : OUTMODEL!ObjectSetExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule DestroyAction {
    from s : INMODEL!DestroyAction
    to t : OUTMODEL!DestroyAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule Link {
    from s : INMODEL!Link (s.oclIsTypeOf(INMODEL!Link))
    to t : OUTMODEL!Link mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        association <- s.association,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule CollaborationInstanceSet {
    from s : INMODEL!CollaborationInstanceSet
    to t : OUTMODEL!CollaborationInstanceSet mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        interactionInstanceSet <- s.interactionInstanceSet,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        collaboration <- s.collaboration,
        templateParameter <- s.templateParameter,
        constrainingElement <- s.constrainingElement,
        participatingLink <- s.participatingLink,
        participatingInstance <- s.participatingInstance,
        clientDependency <- s.clientDependency)
}

rule Interaction {
    from s : INMODEL!Interaction
    to t : OUTMODEL!Interaction mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        message <- s.message,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule UseCase {
    from s : INMODEL!UseCase
    to t : OUTMODEL!UseCase mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        extend <- s.extend,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        include <- s.include,
        templateParameter <- s.templateParameter,
        extensionPoint <- s.extensionPoint,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule Collaboration {
    from s : INMODEL!Collaboration
    to t : OUTMODEL!Collaboration mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        representedOperation <- s.representedOperation,
        taggedValue <- s.taggedValue,
        usedCollaboration <- s.usedCollaboration,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        representedClassifier <- s.representedClassifier,
        targetFlow <- s.targetFlow,
        constrainingElement <- s.constrainingElement,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        interaction <- s.interaction,
        generalization <- s.generalization,
        clientDependency <- s.clientDependency)
}

rule IterationExpression {
    from s : INMODEL!IterationExpression
    to t : OUTMODEL!IterationExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule Operation {
    from s : INMODEL!Operation
    to t : OUTMODEL!Operation mapsTo s (
        specification <- s.specification,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        isQuery <- s.isQuery,
        name <- s.name,
        concurrency <- s.concurrency,
        isRoot <- s.isRoot,
        ownerScope <- s.ownerScope,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        clientDependency <- s.clientDependency)
}

rule ComponentInstance {
    from s : INMODEL!ComponentInstance
    to t : OUTMODEL!ComponentInstance mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        nodeInstance <- s.nodeInstance,
        sourceFlow <- s.sourceFlow,
        resident <- s.resident,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Interface {
    from s : INMODEL!Interface
    to t : OUTMODEL!Interface mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule ElementResidence {
    from s : INMODEL!ElementResidence
    to t : OUTMODEL!ElementResidence mapsTo s (
        visibility <- s.visibility,
        resident <- s.resident)
}

rule CallEvent {
    from s : INMODEL!CallEvent
    to t : OUTMODEL!CallEvent mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        operation <- s.operation,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule AttributeLink {
    from s : INMODEL!AttributeLink
    to t : OUTMODEL!AttributeLink mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        value <- s.value,
        attribute <- s.attribute,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Reception {
    from s : INMODEL!Reception
    to t : OUTMODEL!Reception mapsTo s (
        specification <- s.specification,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isQuery <- s.isQuery,
        name <- s.name,
        ownerScope <- s.ownerScope,
        signal <- s.signal,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        clientDependency <- s.clientDependency)
}

rule Include {
    from s : INMODEL!Include
    to t : OUTMODEL!Include mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        base <- s.base,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        addition <- s.addition,
        clientDependency <- s.clientDependency)
}

rule ActionState {
    from s : INMODEL!ActionState (s.oclIsTypeOf(INMODEL!ActionState))
    to t : OUTMODEL!ActionState mapsTo s (
        dynamicMultiplicity <- s.dynamicMultiplicity,
        isDynamic <- s.isDynamic,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Pseudostate {
    from s : INMODEL!Pseudostate
    to t : OUTMODEL!Pseudostate mapsTo s (
        kind <- s.kind,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        outgoing <- s.outgoing,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule LinkEnd {
    from s : INMODEL!LinkEnd
    to t : OUTMODEL!LinkEnd mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        instance <- s.instance,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        qualifiedValue <- s.qualifiedValue,
        associationEnd <- s.associationEnd,
        clientDependency <- s.clientDependency)
}

rule AssociationRole {
    from s : INMODEL!AssociationRole
    to t : OUTMODEL!AssociationRole mapsTo s (
        multiplicity <- s.multiplicity,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        conformingLink <- s.conformingLink,
        taggedValue <- s.taggedValue,
        message <- s.message,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        base <- s.base,
        generalization <- s.generalization,
        connection <- s.connection,
        clientDependency <- s.clientDependency)
}

rule TimeExpression {
    from s : INMODEL!TimeExpression
    to t : OUTMODEL!TimeExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule LinkObject {
    from s : INMODEL!LinkObject
    to t : OUTMODEL!LinkObject mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        association <- s.association,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        connection <- s.connection,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Subsystem {
    from s : INMODEL!Subsystem
    to t : OUTMODEL!Subsystem mapsTo s (
        isInstantiable <- s.isInstantiable,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        elementImport <- s.elementImport,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule BooleanExpression {
    from s : INMODEL!BooleanExpression
    to t : OUTMODEL!BooleanExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule ProcedureExpression {
    from s : INMODEL!ProcedureExpression
    to t : OUTMODEL!ProcedureExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule Association {
    from s : INMODEL!Association (s.oclIsTypeOf(INMODEL!Association))
    to t : OUTMODEL!Association mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        generalization <- s.generalization,
        connection <- s.connection,
        clientDependency <- s.clientDependency)
}

rule Method {
    from s : INMODEL!Method
    to t : OUTMODEL!Method mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        isQuery <- s.isQuery,
        name <- s.name,
        body <- s.body,
        ownerScope <- s.ownerScope,
        taggedValue <- s.taggedValue,
        specification <- s.specification,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        clientDependency <- s.clientDependency)
}

rule Extend {
    from s : INMODEL!Extend
    to t : OUTMODEL!Extend mapsTo s (
        condition <- s.condition,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        extensionPoint <- s.extensionPoint,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        extension <- s.extension,
        base <- s.base,
        clientDependency <- s.clientDependency)
}

rule Comment {
    from s : INMODEL!Comment
    to t : OUTMODEL!Comment mapsTo s (
        body <- s.body,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        annotatedElement <- s.annotatedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule SimpleState {
    from s : INMODEL!SimpleState (s.oclIsTypeOf(INMODEL!SimpleState))
    to t : OUTMODEL!SimpleState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Signal {
    from s : INMODEL!Signal (s.oclIsTypeOf(INMODEL!Signal))
    to t : OUTMODEL!Signal mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        "context" <- s."context",
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule AssociationEnd {
    from s : INMODEL!AssociationEnd (s.oclIsTypeOf(INMODEL!AssociationEnd))
    to t : OUTMODEL!AssociationEnd mapsTo s (
        ordering <- s.ordering,
        targetScope <- s.targetScope,
        isSpecification <- s.isSpecification,
        isNavigable <- s.isNavigable,
        changeability <- s.changeability,
        visibility <- s.visibility,
        multiplicity <- s.multiplicity,
        name <- s.name,
        aggregation <- s.aggregation,
        taggedValue <- s.taggedValue,
        qualifier <- s.qualifier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        participant <- s.participant,
        targetFlow <- s.targetFlow,
        specification <- s.specification,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Primitive {
    from s : INMODEL!Primitive
    to t : OUTMODEL!Primitive mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule TaggedValue {
    from s : INMODEL!TaggedValue
    to t : OUTMODEL!TaggedValue mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        dataValue <- s.dataValue,
        name <- s.name,
        referenceValue <- s.referenceValue,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        type <- s.type,
        clientDependency <- s.clientDependency)
}

rule Exception {
    from s : INMODEL!Exception
    to t : OUTMODEL!Exception mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        "context" <- s."context",
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule CreateAction {
    from s : INMODEL!CreateAction
    to t : OUTMODEL!CreateAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        instantiation <- s.instantiation,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule ElementImport {
    from s : INMODEL!ElementImport
    to t : OUTMODEL!ElementImport mapsTo s (
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        alias <- s.alias,
        importedElement <- s.importedElement)
}

rule Parameter {
    from s : INMODEL!Parameter
    to t : OUTMODEL!Parameter mapsTo s (
        defaultValue <- s.defaultValue,
        kind <- s.kind,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        type <- s.type,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule StubState {
    from s : INMODEL!StubState
    to t : OUTMODEL!StubState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        referenceState <- s.referenceState,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        outgoing <- s.outgoing,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Model {
    from s : INMODEL!Model
    to t : OUTMODEL!Model mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        elementImport <- s.elementImport,
        templateParameter <- s.templateParameter,
        generalization <- s.generalization,
        clientDependency <- s.clientDependency)
}

rule SubmachineState {
    from s : INMODEL!SubmachineState (s.oclIsTypeOf(INMODEL!SubmachineState))
    to t : OUTMODEL!SubmachineState mapsTo s (
        isConcurrent <- s.isConcurrent,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        subvertex <- s.subvertex,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        submachine <- s.submachine,
        clientDependency <- s.clientDependency)
}

rule Binding {
    from s : INMODEL!Binding
    to t : OUTMODEL!Binding mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        argument <- s.argument,
        taggedValue <- s.taggedValue,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        client <- s.client,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule FinalState {
    from s : INMODEL!FinalState
    to t : OUTMODEL!FinalState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Constraint {
    from s : INMODEL!Constraint
    to t : OUTMODEL!Constraint mapsTo s (
        body <- s.body,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constrainedElement <- s.constrainedElement,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule SendAction {
    from s : INMODEL!SendAction
    to t : OUTMODEL!SendAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        signal <- s.signal,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule ReturnAction {
    from s : INMODEL!ReturnAction
    to t : OUTMODEL!ReturnAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule ActionExpression {
    from s : INMODEL!ActionExpression
    to t : OUTMODEL!ActionExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule MultiplicityRange {
    from s : INMODEL!MultiplicityRange
    to t : OUTMODEL!MultiplicityRange mapsTo s (
        upper <- s.upper,
        lower <- s.lower)
}

rule CallState {
    from s : INMODEL!CallState
    to t : OUTMODEL!CallState mapsTo s (
        dynamicMultiplicity <- s.dynamicMultiplicity,
        isDynamic <- s.isDynamic,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule MappingExpression {
    from s : INMODEL!MappingExpression
    to t : OUTMODEL!MappingExpression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule SynchState {
    from s : INMODEL!SynchState
    to t : OUTMODEL!SynchState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        bound <- s.bound,
        incoming <- s.incoming,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        outgoing <- s.outgoing,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Class {
    from s : INMODEL!Class (s.oclIsTypeOf(INMODEL!Class))
    to t : OUTMODEL!Class mapsTo s (
        isActive <- s.isActive,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule ExtensionPoint {
    from s : INMODEL!ExtensionPoint
    to t : OUTMODEL!ExtensionPoint mapsTo s (
        location <- s.location,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Flow {
    from s : INMODEL!Flow
    to t : OUTMODEL!Flow mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        target <- s.target,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        source <- s.source,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule EnumerationLiteral {
    from s : INMODEL!EnumerationLiteral
    to t : OUTMODEL!EnumerationLiteral mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ObjectFlowState {
    from s : INMODEL!ObjectFlowState
    to t : OUTMODEL!ObjectFlowState mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isSynch <- s.isSynch,
        incoming <- s.incoming,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        type <- s.type,
        clientDependency <- s.clientDependency)
}

rule ActionSequence {
    from s : INMODEL!ActionSequence
    to t : OUTMODEL!ActionSequence mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        action <- s.action,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule Node {
    from s : INMODEL!Node
    to t : OUTMODEL!Node mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        deployedComponent <- s.deployedComponent,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule Multiplicity {
    from s : INMODEL!Multiplicity
    to t : OUTMODEL!Multiplicity mapsTo s (
        range <- s.range)
}

rule Permission {
    from s : INMODEL!Permission
    to t : OUTMODEL!Permission mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        supplier <- s.supplier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        client <- s.client,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Object {
    from s : INMODEL!Object (s.oclIsTypeOf(INMODEL!Object))
    to t : OUTMODEL!Object mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Actor {
    from s : INMODEL!Actor
    to t : OUTMODEL!Actor mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule ProgrammingLanguageDataType {
    from s : INMODEL!ProgrammingLanguageDataType
    to t : OUTMODEL!ProgrammingLanguageDataType mapsTo s (
        expression <- s.expression,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule Attribute {
    from s : INMODEL!Attribute
    to t : OUTMODEL!Attribute mapsTo s (
        changeability <- s.changeability,
        ordering <- s.ordering,
        isSpecification <- s.isSpecification,
        targetScope <- s.targetScope,
        visibility <- s.visibility,
        name <- s.name,
        initialValue <- s.initialValue,
        ownerScope <- s.ownerScope,
        multiplicity <- s.multiplicity,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        type <- s.type,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule CompositeState {
    from s : INMODEL!CompositeState (s.oclIsTypeOf(INMODEL!CompositeState))
    to t : OUTMODEL!CompositeState mapsTo s (
        isConcurrent <- s.isConcurrent,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        subvertex <- s.subvertex,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule DataType {
    from s : INMODEL!DataType (s.oclIsTypeOf(INMODEL!DataType))
    to t : OUTMODEL!DataType mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule TerminateAction {
    from s : INMODEL!TerminateAction
    to t : OUTMODEL!TerminateAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule Expression {
    from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
    to t : OUTMODEL!Expression mapsTo s (
        body <- s.body,
        language <- s.language)
}

rule ClassifierRole {
    from s : INMODEL!ClassifierRole
    to t : OUTMODEL!ClassifierRole mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        multiplicity <- s.multiplicity,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        base <- s.base,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        availableContents <- s.availableContents,
        conformingInstance <- s.conformingInstance,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        availableFeature <- s.availableFeature,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule NodeInstance {
    from s : INMODEL!NodeInstance
    to t : OUTMODEL!NodeInstance mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        resident <- s.resident,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule TimeEvent {
    from s : INMODEL!TimeEvent
    to t : OUTMODEL!TimeEvent mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        when <- s.when,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule AssociationEndRole {
    from s : INMODEL!AssociationEndRole
    to t : OUTMODEL!AssociationEndRole mapsTo s (
        ordering <- s.ordering,
        targetScope <- s.targetScope,
        collaborationMultiplicity <- s.collaborationMultiplicity,
        isSpecification <- s.isSpecification,
        isNavigable <- s.isNavigable,
        changeability <- s.changeability,
        visibility <- s.visibility,
        multiplicity <- s.multiplicity,
        name <- s.name,
        aggregation <- s.aggregation,
        taggedValue <- s.taggedValue,
        qualifier <- s.qualifier,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        availableQualifier <- s.availableQualifier,
        stereotype <- s.stereotype,
        participant <- s.participant,
        targetFlow <- s.targetFlow,
        specification <- s.specification,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        base <- s.base,
        clientDependency <- s.clientDependency)
}

rule SubsystemInstance {
    from s : INMODEL!SubsystemInstance
    to t : OUTMODEL!SubsystemInstance mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        linkEnd <- s.linkEnd,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        componentInstance <- s.componentInstance,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        slot <- s.slot,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        ownedInstance <- s.ownedInstance,
        clientDependency <- s.clientDependency)
}

rule Guard {
    from s : INMODEL!Guard
    to t : OUTMODEL!Guard mapsTo s (
        isSpecification <- s.isSpecification,
        expression <- s.expression,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule AssociationClass {
    from s : INMODEL!AssociationClass
    to t : OUTMODEL!AssociationClass mapsTo s (
        isActive <- s.isActive,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        connection <- s.connection,
        clientDependency <- s.clientDependency)
}

rule InteractionInstanceSet {
    from s : INMODEL!InteractionInstanceSet
    to t : OUTMODEL!InteractionInstanceSet mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        interaction <- s.interaction,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        participatingStimulus <- s.participatingStimulus,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Package {
    from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
    to t : OUTMODEL!Package mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        elementImport <- s.elementImport,
        templateParameter <- s.templateParameter,
        generalization <- s.generalization,
        clientDependency <- s.clientDependency)
}

rule Argument {
    from s : INMODEL!Argument
    to t : OUTMODEL!Argument mapsTo s (
        value <- s.value,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Partition {
    from s : INMODEL!Partition
    to t : OUTMODEL!Partition mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        contents <- s.contents,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule SignalEvent {
    from s : INMODEL!SignalEvent
    to t : OUTMODEL!SignalEvent mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        signal <- s.signal,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Enumeration {
    from s : INMODEL!Enumeration
    to t : OUTMODEL!Enumeration mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        literal <- s.literal,
        feature <- s.feature,
        generalization <- s.generalization,
        powertypeRange <- s.powertypeRange,
        clientDependency <- s.clientDependency)
}

rule SubactivityState {
    from s : INMODEL!SubactivityState
    to t : OUTMODEL!SubactivityState mapsTo s (
        isConcurrent <- s.isConcurrent,
        dynamicArguments <- s.dynamicArguments,
        dynamicMultiplicity <- s.dynamicMultiplicity,
        isSpecification <- s.isSpecification,
        isDynamic <- s.isDynamic,
        visibility <- s.visibility,
        name <- s.name,
        incoming <- s.incoming,
        subvertex <- s.subvertex,
        taggedValue <- s.taggedValue,
        internalTransition <- s.internalTransition,
        sourceFlow <- s.sourceFlow,
        doActivity <- s.doActivity,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        deferrableEvent <- s.deferrableEvent,
        outgoing <- s.outgoing,
        entry <- s.entry,
        targetFlow <- s.targetFlow,
        exit <- s.exit,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        submachine <- s.submachine,
        clientDependency <- s.clientDependency)
}

rule UninterpretedAction {
    from s : INMODEL!UninterpretedAction
    to t : OUTMODEL!UninterpretedAction mapsTo s (
        target <- s.target,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        isAsynchronous <- s.isAsynchronous,
        visibility <- s.visibility,
        name <- s.name,
        script <- s.script,
        taggedValue <- s.taggedValue,
        sourceFlow <- s.sourceFlow,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        actualArgument <- s.actualArgument,
        clientDependency <- s.clientDependency)
}

rule TemplateParameter {
    from s : INMODEL!TemplateParameter
    to t : OUTMODEL!TemplateParameter mapsTo s (
        parameter <- s.parameter,
        defaultElement <- s.defaultElement)
}

rule StateMachine {
    from s : INMODEL!StateMachine (s.oclIsTypeOf(INMODEL!StateMachine))
    to t : OUTMODEL!StateMachine mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        taggedValue <- s.taggedValue,
        transitions <- s.transitions,
        sourceFlow <- s.sourceFlow,
        top <- s.top,
        constraint <- s.constraint,
        stereotype <- s.stereotype,
        submachineState <- s.submachineState,
        targetFlow <- s.targetFlow,
        comment <- s.comment,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

