-- $Id$
module Observer;

create OUT : OUTMODEL from IN : INMODEL;

uses strings;
uses Java;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context INMODEL!Attribute def : javaSetterNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (this.' + self.name + ' != ' + self.name + ') {\n' +
	'    // Begin original body\n' +
	body +
	'    // End original body\n' +
	self.name.javaNotifyStanza(self.type.name) +
	'}\n' +
	'// End Observable stanza';
	
helper context INMODEL!Attribute def : javaAdderNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (! this.' + self.name + '.contains(' + self.name + ')) {\n' +
	'    // Begin original body\n' +
	body +
	'    // End original body\n' +
	self.name.javaNotifyStanza(self.type.name) +
	'}\n' +
	'// End Observable stanza';
	
helper context INMODEL!Attribute def : javaRemoverNotify(body : String) : String =
	'// Begin Observable stanza\n' +
	'if (this.' + self.name + '.contains(' + self.name + ')) {\n' +
	'    // Begin original body\n' +
	body +
	'    // End original body\n' +
	self.name.javaNotifyStanza(self.type.name) +
	'}\n' +
	'// End Observable stanza';

helper context String def : class() : INMODEL!Class =
	INMODEL!Class.allInstances()->select(c|c.name=self)->first();

helper context String def : interface() : INMODEL!Interface =
	INMODEL!Interface.allInstances()->select(c|c.name=self)->first();

helper context String def : stereotype() : INMODEL!Stereotype =
	INMODEL!Stereotype.allInstances()->select(c|c.name=self)->first();

helper context INMODEL!AssociationEnd def : otherEnd() : INMODEL!AssociationEnd =
	self.association.connection->select(x|x<>self)->first();

helper context INMODEL!AssociationEnd def : navigableFrom() : INMODEL!Classifier =
	self.otherEnd().participant;

helper context INMODEL!Attribute def : hasAssociationEnd() : Boolean =
	not INMODEL!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->isEmpty();

helper context INMODEL!Attribute def : associationEnd() : INMODEL!AssociationEnd =
	INMODEL!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->first();

helper context INMODEL!Dependency def : isAccessorDependency() : Boolean =
	not self.stereotype->select(s|s.name='accessor')->isEmpty();
	
helper context INMODEL!Operation def : isAccessor() : Boolean =
	not self.clientDependency->select(d|d.isAccessorDependency())->isEmpty();

helper context INMODEL!Operation def : accessorFor() : INMODEL!Attribute =
	self.clientDependency->select(d|d.isAccessorDependency())->first()
		.supplier->select(a|a.oclIsKindOf(INMODEL!Attribute))->first();

helper context INMODEL!Operation def : isSubscriber() : Boolean =
	if self.isAccessor() then
		self.accessorFor().hasSubscribesAssociation()
	else
		false
	endif;

helper context INMODEL!Attribute def : hasSubscribesAssociation() : Boolean =
	if self.hasAssociationEnd() then
		not self.associationEnd().association.stereotype
			->select(s|s.name='subscribe')->isEmpty()
	else
		false
	endif;
	
helper context INMODEL!GeneralizableElement def : isObservableType() : Boolean =
	not self.stereotype->select(s|s.name='Observable')->isEmpty();

helper context INMODEL!GeneralizableElement def : isObservableKind() : Boolean =
	if self.isObservableType() then
		true
	else
		not self.generalization->select(g|g.parent.isObservableKind())->isEmpty()
	endif;

helper context INMODEL!GeneralizableElement def : isObserverType() : Boolean =
	not self.stereotype->select(s|s.name='Observer')->isEmpty();

helper context INMODEL!GeneralizableElement def : isObserverKind() : Boolean =
	if self.isObserverType() then
		true
	else
		not self.generalization->select(g|g.parent.isObserverKind())->isEmpty()
	endif;

helper context INMODEL!ProcedureExpression def : method() : INMODEL!Method =
	INMODEL!Method.allInstances()->select(m|m.body=self)->first();

helper context INMODEL!Operation def : javaNotify(body : String) : String =
	if self.name.startsWith('remove') then
		self.accessorFor().javaRemoverNotify(body)
	else if self.name.startsWith('add') then
		self.accessorFor().javaAdderNotify(body)
	else if self.name.startsWith('set') then
		self.accessorFor().javaSetterNotify(body)
	else
		body
	endif endif endif;

helper context INMODEL!Operation def : javaSubscribe(body : String) : String =
	if self.name.startsWith('remove') then
		self.accessorFor().name.javaRemoverSubscribe(body)
	else if self.name.startsWith('add') then
		self.accessorFor().name.javaAdderSubscribe(body)
	else if self.name.startsWith('set') then
		self.accessorFor().name.javaSetterSubscribe(body)
	else
		body
	endif endif endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- non-mapsTo rules begin
-- ======================================================================

rule ObservableClass {
	from s : INMODEL!Class (s.isObservableType())
	to t : OUTMODEL!Generalization (
	   	namespace <- s.namespace,
		parent <- 'Observable'.class(),
		child <- s)
}

rule ObserverClass {
	from s : INMODEL!Class (s.isObserverType())
	to t : OUTMODEL!Abstraction (
	   	namespace <- s.namespace,
		stereotype <- 'realize'.stereotype(),
		supplier <- Set{'Observer'.interface()},
		client <- Set{s}),
	   op : OUTMODEL!Operation (
	   	name <- 'update',
		owner <- s,
		visibility <- #vk_public,
		ownerScope <- #sk_instance,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   o : OUTMODEL!Parameter (
	   	name <- 'o',
		behavioralFeature <- op,
		type <- 'Observable'.class(),
		kind <- #pdk_in),
	   arg : OUTMODEL!Parameter (
	   	name <- 'arg',
		behavioralFeature <- op,
		type <- 'Object'.class(),
		kind <- #pdk_in),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- 'arg'.javaUpdater()),
	   meth : OUTMODEL!Method (
	   	owner <- s,
		body <- mbody,
		specification <- op)
}

-- ======================================================================
-- non-mapsTo rules end
-- ======================================================================

-- ======================================================================
-- mapsTo rules begin
-- ======================================================================

rule ProcedureExpression {
	from s : INMODEL!ProcedureExpression (not (
		 s.method().specification.isAccessor() and
		 (s.method().owner.isObservableKind() or
		  (s.method().owner.isObserverKind() and
		   s.method().specification.isSubscriber()))))
	to t : OUTMODEL!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.body)
}

rule NotifyProcedureExpression {
	from s : INMODEL!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 s.method().owner.isObservableKind() and
		 not (s.method().owner.isObserverKind() and
		      s.method().specification.isSubscriber()))
	to t : OUTMODEL!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaNotify(s.body))
}

rule NotifySubscribeProcedureExpression {
	from s : INMODEL!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 s.method().owner.isObservableKind() and
		 s.method().owner.isObserverKind() and
		 s.method().specification.isSubscriber())
	to t : OUTMODEL!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaNotify(
			s.method().specification.javaSubscribe(s.body)))
}

rule SubscribeProcedureExpression {
	from s : INMODEL!ProcedureExpression (
		 s.method().specification.isAccessor() and
		 not s.method().owner.isObservableKind() and
		 s.method().owner.isObserverKind() and
		 s.method().specification.isSubscriber())
	to t : OUTMODEL!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.method().specification.javaSubscribe(s.body))
}

-- ======================================================================
-- mapsTo rules end
-- ======================================================================

-- ======================================================================
-- model copy begin
-- ======================================================================

rule Model {
	from s : INMODEL!Model
	to t : OUTMODEL!Model mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Package {
	from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
	to t : OUTMODEL!Package mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule DataType {
	from s : INMODEL!DataType
	to t : OUTMODEL!DataType mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Stereotype {
	from s : INMODEL!Stereotype
	to t : OUTMODEL!Stereotype mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		visibility <- s.visibility,
		baseClass <- s.baseClass)
}

rule TaggedValue {
	from s : INMODEL!TaggedValue
	to t : OUTMODEL!TaggedValue mapsTo s (
		name <- s.name,
		modelElement <- s.modelElement,
		isSpecification <- s.isSpecification,
		dataValue <- s.dataValue,
		type <- s.type,
		referenceValue <- s.referenceValue)
}

rule TagDefinition {
	from s : INMODEL!TagDefinition
	to t : OUTMODEL!TagDefinition mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		owner <- s.owner,
		tagType <- s.tagType,
		isSpecification <- s.isSpecification,
		multiplicity <- s.multiplicity)
}

rule Class {
	from s : INMODEL!Class
	to t : OUTMODEL!Class mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract,
		isActive <- s.isActive)
}

rule Interface {
	from s : INMODEL!Interface
	to t : OUTMODEL!Interface mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Attribute {
	from s : INMODEL!Attribute
	to t : OUTMODEL!Attribute mapsTo s (
		name <- s.name,
		owner <- s.owner,
		stereotype <- s.stereotype,
		type <- s.type,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		changeability <- s.changeability,
		isSpecification <- s.isSpecification,
		associationEnd <- s.associationEnd,
		initialValue <- s.initialValue)
}

rule Expression {
	from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
	to t : OUTMODEL!Expression mapsTo s (
		language <- s.language,
		body <- s.body)
}

rule Operation {
	from s : INMODEL!Operation
	to t : OUTMODEL!Operation mapsTo s (
		name <- s.name,
		owner <- s.owner,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isQuery <- s.isQuery,
		isAbstract <- s.isAbstract,
		concurrency <- s.concurrency,
		parameter <- s.parameter)
}

rule Parameter {
	from s : INMODEL!Parameter
	to t : OUTMODEL!Parameter mapsTo s (
		name <- s.name,
		stereotype <- s.stereotype,
		type <- s.type,
		kind <- s.kind,
		isSpecification <- s.isSpecification,
		defaultValue <- s.defaultValue)
}

rule Method {
	from s : INMODEL!Method
	to t : OUTMODEL!Method mapsTo s (
		owner <- s.owner,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		isQuery <- s.isQuery,
		body <- s.body,
		specification <- s.specification)
}

rule Association {
	from s : INMODEL!Association
	to t : OUTMODEL!Association mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isAbstract <- s.isAbstract)
}

rule AssociationEnd {
	from s : INMODEL!AssociationEnd
	to t : OUTMODEL!AssociationEnd mapsTo s (
		name <- s.name,
		association <- s.association,
		stereotype <- s.stereotype,
		participant <- s.participant,
		visibility <- s.visibility,
		targetScope <- s.targetScope,
		changeability <- s.changeability,
		ordering <- s.ordering,
		aggregation <- s.aggregation,
		isNavigable <- s.isNavigable,
		multiplicity <- s.multiplicity)
}

rule Multiplicity {
	from s : INMODEL!Multiplicity
	to t : OUTMODEL!Multiplicity mapsTo s
}

rule MultiplicityRange {
	from s : INMODEL!MultiplicityRange
	to t : OUTMODEL!MultiplicityRange mapsTo s (
		multiplicity <- s.multiplicity,
		lower <- s.lower,
		upper <- s.upper)
}

rule Dependency {
	from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
	to t : OUTMODEL!Dependency mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		client <- s.client,
		supplier <- s.supplier)
}

rule Abstraction {
	from s : INMODEL!Abstraction
	to t : OUTMODEL!Abstraction mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		client <- s.client,
		supplier <- s.supplier)
}

rule Generalization {
	from s : INMODEL!Generalization
	to t : OUTMODEL!Generalization mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		parent <- s.parent,
		child <- s.child)
}

-- ======================================================================
-- model copy end
-- ======================================================================
