-- $Id$
module AssociationAttributes;

create OUT : OUTMODEL from IN : INMODEL;

uses Java;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context String def : dataType() : INMODEL!DataType =
	INMODEL!DataType.allInstances()->select(c|c.name=self)->first();

helper context INMODEL!AssociationEnd def : navigableFrom() : INMODEL!Classifier =
	self.association.connection->select(x|x<>self)->first().participant;

helper context INMODEL!AssociationEnd def : isSingle() : Boolean =
	self.multiplicity.range->select(r|r.upper<>1)->isEmpty();

helper context INMODEL!AssociationEnd def : type() : INMODEL!Classifier =
	if self.isSingle() then
		self.participant
	else if self.ordering = #ok_ordered then
		'Sequence'.dataType()
	else
		'Collection'.dataType()
	endif endif;

helper context INMODEL!ModelElement def : hasTaggedValue(type : String) : Boolean =
	not self.taggedValue->select(v|v.type.name=type)->isEmpty();

helper context INMODEL!ModelElement def : taggedValue(type : String) : INMODEL!TaggedValue =
	self.taggedValue->select(v|v.type.name=type)->first();

helper context INMODEL!AssociationEnd def : instance() : String =
	if self.hasTaggedValue('gentleware-initialValue') then
		self.taggedValue('gentleware-initialValue').dataValue->asSequence()->first()
	else
		self.type().name.java2Instance()
	endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================
	
-- ======================================================================
-- non-mapsTo rules begin
-- ======================================================================

rule AssociationEndAttribute {
	from s : INMODEL!AssociationEnd (
		s.isNavigable and
		s.navigableFrom().oclIsKindOf(INMODEL!Class))
	to t : OUTMODEL!Attribute (
	   	name <- s.name,
		owner <- s.navigableFrom(),
		type <- s.type(),
		visibility <- s.visibility,
		ownerScope <- s.targetScope,
		changeability <- s.changeability,
		initialValue <- v),
	   v : OUTMODEL!Expression (
	   	language <- 'java',
		body <- s.instance())
}

-- ======================================================================
-- non-mapsTo rules end
-- ======================================================================
	
-- ======================================================================
-- model copy begin
-- ======================================================================

rule Model {
	from s : INMODEL!Model
	to t : OUTMODEL!Model mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Package {
	from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
	to t : OUTMODEL!Package mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule DataType {
	from s : INMODEL!DataType
	to t : OUTMODEL!DataType mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Stereotype {
	from s : INMODEL!Stereotype
	to t : OUTMODEL!Stereotype mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		visibility <- s.visibility,
		baseClass <- s.baseClass)
}

rule TaggedValue {
	from s : INMODEL!TaggedValue
	to t : OUTMODEL!TaggedValue mapsTo s (
		name <- s.name,
		modelElement <- s.modelElement,
		isSpecification <- s.isSpecification,
		dataValue <- s.dataValue,
		type <- s.type,
		referenceValue <- s.referenceValue)
}

rule TagDefinition {
	from s : INMODEL!TagDefinition
	to t : OUTMODEL!TagDefinition mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		owner <- s.owner,
		tagType <- s.tagType,
		isSpecification <- s.isSpecification,
		multiplicity <- s.multiplicity)
}

rule Class {
	from s : INMODEL!Class
	to t : OUTMODEL!Class mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract,
		isActive <- s.isActive)
}

rule Interface {
	from s : INMODEL!Interface
	to t : OUTMODEL!Interface mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Attribute {
	from s : INMODEL!Attribute
	to t : OUTMODEL!Attribute mapsTo s (
		name <- s.name,
		owner <- s.owner,
		stereotype <- s.stereotype,
		type <- s.type,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		changeability <- s.changeability,
		isSpecification <- s.isSpecification,
		associationEnd <- s.associationEnd,
		initialValue <- s.initialValue)
}

rule Expression {
	from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
	to t : OUTMODEL!Expression mapsTo s (
		language <- s.language,
		body <- s.body)
}

rule Operation {
	from s : INMODEL!Operation
	to t : OUTMODEL!Operation mapsTo s (
		name <- s.name,
		owner <- s.owner,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isQuery <- s.isQuery,
		isAbstract <- s.isAbstract,
		concurrency <- s.concurrency,
		parameter <- s.parameter)
}

rule Parameter {
	from s : INMODEL!Parameter
	to t : OUTMODEL!Parameter mapsTo s (
		name <- s.name,
		stereotype <- s.stereotype,
		type <- s.type,
		kind <- s.kind,
		isSpecification <- s.isSpecification,
		defaultValue <- s.defaultValue)
}

rule Method {
	from s : INMODEL!Method
	to t : OUTMODEL!Method mapsTo s (
		owner <- s.owner,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		isQuery <- s.isQuery,
		body <- s.body,
		specification <- s.specification)
}

rule ProcedureExpression {
	from s : INMODEL!ProcedureExpression
	to t : OUTMODEL!ProcedureExpression mapsTo s (
		language <- s.language,
		body <- s.body)
}

rule Association {
	from s : INMODEL!Association
	to t : OUTMODEL!Association mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isAbstract <- s.isAbstract)
}

rule AssociationEnd {
	from s : INMODEL!AssociationEnd
	to t : OUTMODEL!AssociationEnd mapsTo s (
		name <- s.name,
		association <- s.association,
		stereotype <- s.stereotype,
		participant <- s.participant,
		visibility <- s.visibility,
		targetScope <- s.targetScope,
		changeability <- s.changeability,
		ordering <- s.ordering,
		aggregation <- s.aggregation,
		isNavigable <- s.isNavigable,
		multiplicity <- s.multiplicity)
}

rule Multiplicity {
	from s : INMODEL!Multiplicity
	to t : OUTMODEL!Multiplicity mapsTo s
}

rule MultiplicityRange {
	from s : INMODEL!MultiplicityRange
	to t : OUTMODEL!MultiplicityRange mapsTo s (
		multiplicity <- s.multiplicity,
		lower <- s.lower,
		upper <- s.upper)
}

rule Dependency {
	from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
	to t : OUTMODEL!Dependency mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		client <- s.client,
		supplier <- s.supplier)
}

rule Abstraction {
	from s : INMODEL!Abstraction
	to t : OUTMODEL!Abstraction mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		client <- s.client,
		supplier <- s.supplier)
}

rule Generalization {
	from s : INMODEL!Generalization
	to t : OUTMODEL!Generalization mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification,
		parent <- s.parent,
		child <- s.child)
}

rule Collaboration {
	from s : INMODEL!Collaboration
	to t : OUTMODEL!Collaboration mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule CollaborationInstanceSet {
	from s : INMODEL!CollaborationInstanceSet
	to t : OUTMODEL!CollaborationInstanceSet mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		collaboration <- s.collaboration,
		interactionInstanceSet <- s.interactionInstanceSet,
		participatingInstance <- s.participatingInstance,
		participatingLink <- s.participatingLink,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification)
}

rule InteractionInstanceSet {
	from s : INMODEL!InteractionInstanceSet
	to t : OUTMODEL!InteractionInstanceSet mapsTo s (
		name <- s.name,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification)
}

rule Object {
	from s : INMODEL!Object
	to t : OUTMODEL!Object mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		classifier <- s.classifier,
		linkEnd <- s.linkEnd,
		ownedLink <- s.ownedLink,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule Link {
	from s : INMODEL!Link
	to t : OUTMODEL!Link mapsTo s (
		name <- s.name,
		association <- s.association,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule LinkEnd {
	from s : INMODEL!LinkEnd
	to t : OUTMODEL!LinkEnd mapsTo s (
		name <- s.name,
		link <- s.link,
		instance <- s.instance,
		associationEnd <- s.associationEnd,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule Message {
	from s : INMODEL!Message
	to t : OUTMODEL!Message mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		conformingStimulus <- s.conformingStimulus,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule Stimulus {
	from s : INMODEL!Stimulus
	to t : OUTMODEL!Stimulus mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		sender <- s.sender,
		receiver <- s.receiver,
		communicationLink <- s.communicationLink,
		dispatchAction <- s.dispatchAction,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule CallAction {
	from s : INMODEL!CallAction
	to t : OUTMODEL!CallAction mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		actualArgument <- s.actualArgument,
		isAsynchronous <- s.isAsynchronous,
		operation <- s.operation,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule ReturnAction {
	from s : INMODEL!ReturnAction
	to t : OUTMODEL!ReturnAction mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		actualArgument <- s.actualArgument,
		isAsynchronous <- s.isAsynchronous,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule Argument {
	from s : INMODEL!Argument
	to t : OUTMODEL!Argument mapsTo s (
		name <- s.name,
		value <- s.value,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isSpecification <- s.isSpecification)
}

rule Actor {
	from s : INMODEL!Actor
	to t : OUTMODEL!Actor mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule UseCase {
	from s : INMODEL!UseCase
	to t : OUTMODEL!UseCase mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		stereotype <- s.stereotype,
		visibility <- s.visibility,
		isRoot <- s.isRoot,
		isLeaf <- s.isLeaf,
		isSpecification <- s.isSpecification,
		isAbstract <- s.isAbstract)
}

rule Include {
	from s : INMODEL!Include
	to t : OUTMODEL!Include mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		base <- s.base,
		addition <- s.addition,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification)
}

rule Extend {
	from s : INMODEL!Extend
	to t : OUTMODEL!Extend mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		base <- s.base,
		extension <- s.extension,
		extensionPoint <- s.extensionPoint,
		condition <- s.condition,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification)
}

rule ExtensionPoint {
	from s : INMODEL!ExtensionPoint
	to t : OUTMODEL!ExtensionPoint mapsTo s (
		name <- s.name,
		namespace <- s.namespace,
		location <- s.location,
		useCase <- s.useCase,
		stereotype <- s.stereotype,
		isSpecification <- s.isSpecification)
}

-- ======================================================================
-- model copy end
-- ======================================================================
