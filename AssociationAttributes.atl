-- $Id$
module AssociationAttributes;

create OUT : OUTMODEL from IN : INMODEL;

uses Java;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context String def : dataType() : INMODEL!DataType =
	INMODEL!DataType.allInstances()->select(c|c.name=self)->first();

helper context INMODEL!AssociationEnd def : navigableFrom() : INMODEL!Classifier =
	self.association.connection->select(x|x<>self)->first().participant;

helper context INMODEL!AssociationEnd def : isSingle() : Boolean =
	self.multiplicity.range->select(r|r.upper<>1)->isEmpty();

helper context INMODEL!AssociationEnd def : type() : INMODEL!Classifier =
	if self.isSingle() then
		self.participant
	else if self.ordering = #ok_ordered then
		'Sequence'.dataType()
	else
		'Collection'.dataType()
	endif endif;

helper context INMODEL!ModelElement def : hasTaggedValue(type : String) : Boolean =
	not self.taggedValue->select(v|v.type.name=type)->isEmpty();

helper context INMODEL!ModelElement def : taggedValue(type : String) : INMODEL!TaggedValue =
	self.taggedValue->select(v|v.type.name=type)->first();

helper context INMODEL!AssociationEnd def : instance() : String =
	if self.hasTaggedValue('gentleware-initialValue') then
		self.taggedValue('gentleware-initialValue').dataValue->asSequence()->first()
	else
		self.type().name.java2Instance()
	endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================
	
-- ======================================================================
-- non-mapsTo rules begin
-- ======================================================================

rule AssociationEndAttribute {
	from s : INMODEL!AssociationEnd (
		s.isNavigable and
		s.navigableFrom().oclIsKindOf(INMODEL!Class))
	to t : OUTMODEL!Attribute (
		name <- s.name,
		owner <- s.navigableFrom(),
		type <- s.type(),
		visibility <- s.visibility,
		ownerScope <- s.targetScope,
		changeability <- s.changeability,
		initialValue <- v),
	   v : OUTMODEL!Expression (
	   	language <- 'java',
		body <- s.instance())
}

-- ======================================================================
-- non-mapsTo rules end
-- ======================================================================
	
-- ======================================================================
-- model copy begin
-- ======================================================================
-- Generated by: ModelCopyGenerator.atl 875 2005-04-20 13:46:26Z dwagelaa

rule Message {
    from s : INMODEL!Message
    to t : OUTMODEL!Message mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        predecessor <- s.predecessor,
        templateParameter <- s.templateParameter,
        communicationConnection <- s.communicationConnection,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        conformingStimulus <- s.conformingStimulus,
        clientDependency <- s.clientDependency,
        action <- s.action,
        sourceFlow <- s.sourceFlow,
        sender <- s.sender,
        activator <- s.activator,
        receiver <- s.receiver)
}

rule Class {
    from s : INMODEL!Class (s.oclIsTypeOf(INMODEL!Class))
    to t : OUTMODEL!Class mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isActive <- s.isActive,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule SimpleState {
    from s : INMODEL!SimpleState (s.oclIsTypeOf(INMODEL!SimpleState))
    to t : OUTMODEL!SimpleState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Operation {
    from s : INMODEL!Operation
    to t : OUTMODEL!Operation mapsTo s (
        isAbstract <- s.isAbstract,
        isRoot <- s.isRoot,
        concurrency <- s.concurrency,
        specification <- s.specification,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        ownerScope <- s.ownerScope,
        isQuery <- s.isQuery,
        parameter <- s.parameter,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MultiplicityRange {
    from s : INMODEL!MultiplicityRange
    to t : OUTMODEL!MultiplicityRange mapsTo s (
        upper <- s.upper,
        lower <- s.lower)
}

rule TemplateParameter {
    from s : INMODEL!TemplateParameter
    to t : OUTMODEL!TemplateParameter mapsTo s (
        defaultElement <- s.defaultElement,
        parameter <- s.parameter)
}

rule Binding {
    from s : INMODEL!Binding
    to t : OUTMODEL!Binding mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        comment <- s.comment,
        client <- s.client,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        argument <- s.argument)
}

rule DataValue {
    from s : INMODEL!DataValue
    to t : OUTMODEL!DataValue mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        slot <- s.slot)
}

rule Exception {
    from s : INMODEL!Exception
    to t : OUTMODEL!Exception mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule Actor {
    from s : INMODEL!Actor
    to t : OUTMODEL!Actor mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule SubactivityState {
    from s : INMODEL!SubactivityState
    to t : OUTMODEL!SubactivityState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isDynamic <- s.isDynamic,
        dynamicMultiplicity <- s.dynamicMultiplicity,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        isConcurrent <- s.isConcurrent,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        subvertex <- s.subvertex,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        submachine <- s.submachine,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Guard {
    from s : INMODEL!Guard
    to t : OUTMODEL!Guard mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        expression <- s.expression,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Flow {
    from s : INMODEL!Flow
    to t : OUTMODEL!Flow mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        target <- s.target,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        source <- s.source,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule AttributeLink {
    from s : INMODEL!AttributeLink
    to t : OUTMODEL!AttributeLink mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        attribute <- s.attribute,
        templateParameter <- s.templateParameter,
        value <- s.value,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Object {
    from s : INMODEL!Object (s.oclIsTypeOf(INMODEL!Object))
    to t : OUTMODEL!Object mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        slot <- s.slot)
}

rule Permission {
    from s : INMODEL!Permission
    to t : OUTMODEL!Permission mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        comment <- s.comment,
        client <- s.client,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ActionExpression {
    from s : INMODEL!ActionExpression
    to t : OUTMODEL!ActionExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule CallAction {
    from s : INMODEL!CallAction
    to t : OUTMODEL!CallAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        operation <- s.operation,
        sourceFlow <- s.sourceFlow)
}

rule UninterpretedAction {
    from s : INMODEL!UninterpretedAction
    to t : OUTMODEL!UninterpretedAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ClassifierRole {
    from s : INMODEL!ClassifierRole
    to t : OUTMODEL!ClassifierRole mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        multiplicity <- s.multiplicity,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        availableContents <- s.availableContents,
        base <- s.base,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        conformingInstance <- s.conformingInstance,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        availableFeature <- s.availableFeature)
}

rule CollaborationInstanceSet {
    from s : INMODEL!CollaborationInstanceSet
    to t : OUTMODEL!CollaborationInstanceSet mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        participatingInstance <- s.participatingInstance,
        stereotype <- s.stereotype,
        collaboration <- s.collaboration,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        constrainingElement <- s.constrainingElement,
        interactionInstanceSet <- s.interactionInstanceSet,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        participatingLink <- s.participatingLink)
}

rule Include {
    from s : INMODEL!Include
    to t : OUTMODEL!Include mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        base <- s.base,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        addition <- s.addition)
}

rule Usage {
    from s : INMODEL!Usage
    to t : OUTMODEL!Usage mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        comment <- s.comment,
        client <- s.client,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Subsystem {
    from s : INMODEL!Subsystem
    to t : OUTMODEL!Subsystem mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isInstantiable <- s.isInstantiable,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        elementImport <- s.elementImport,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule Argument {
    from s : INMODEL!Argument
    to t : OUTMODEL!Argument mapsTo s (
        name <- s.name,
        value <- s.value,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule MappingExpression {
    from s : INMODEL!MappingExpression
    to t : OUTMODEL!MappingExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule TemplateArgument {
    from s : INMODEL!TemplateArgument
    to t : OUTMODEL!TemplateArgument mapsTo s (
        modelElement <- s.modelElement)
}

rule EnumerationLiteral {
    from s : INMODEL!EnumerationLiteral
    to t : OUTMODEL!EnumerationLiteral mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Enumeration {
    from s : INMODEL!Enumeration
    to t : OUTMODEL!Enumeration mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        literal <- s.literal,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule Comment {
    from s : INMODEL!Comment
    to t : OUTMODEL!Comment mapsTo s (
        name <- s.name,
        body <- s.body,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        annotatedElement <- s.annotatedElement,
        sourceFlow <- s.sourceFlow)
}

rule Node {
    from s : INMODEL!Node
    to t : OUTMODEL!Node mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        deployedComponent <- s.deployedComponent,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule ArgListsExpression {
    from s : INMODEL!ArgListsExpression
    to t : OUTMODEL!ArgListsExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule IterationExpression {
    from s : INMODEL!IterationExpression
    to t : OUTMODEL!IterationExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule CompositeState {
    from s : INMODEL!CompositeState (s.oclIsTypeOf(INMODEL!CompositeState))
    to t : OUTMODEL!CompositeState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isConcurrent <- s.isConcurrent,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        subvertex <- s.subvertex,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ObjectFlowState {
    from s : INMODEL!ObjectFlowState
    to t : OUTMODEL!ObjectFlowState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSynch <- s.isSynch,
        isSpecification <- s.isSpecification,
        type <- s.type,
        parameter <- s.parameter,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule NodeInstance {
    from s : INMODEL!NodeInstance
    to t : OUTMODEL!NodeInstance mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        resident <- s.resident,
        slot <- s.slot)
}

rule ElementResidence {
    from s : INMODEL!ElementResidence
    to t : OUTMODEL!ElementResidence mapsTo s (
        visibility <- s.visibility,
        resident <- s.resident)
}

rule TimeEvent {
    from s : INMODEL!TimeEvent
    to t : OUTMODEL!TimeEvent mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        when <- s.when,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow)
}

rule Link {
    from s : INMODEL!Link (s.oclIsTypeOf(INMODEL!Link))
    to t : OUTMODEL!Link mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        association <- s.association,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule AssociationClass {
    from s : INMODEL!AssociationClass
    to t : OUTMODEL!AssociationClass mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isActive <- s.isActive,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        connection <- s.connection,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule InteractionInstanceSet {
    from s : INMODEL!InteractionInstanceSet
    to t : OUTMODEL!InteractionInstanceSet mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        participatingStimulus <- s.participatingStimulus,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        interaction <- s.interaction,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ObjectSetExpression {
    from s : INMODEL!ObjectSetExpression
    to t : OUTMODEL!ObjectSetExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule Extend {
    from s : INMODEL!Extend
    to t : OUTMODEL!Extend mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        condition <- s.condition,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        extensionPoint <- s.extensionPoint,
        comment <- s.comment,
        constraint <- s.constraint,
        extension <- s.extension,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        base <- s.base)
}

rule ProcedureExpression {
    from s : INMODEL!ProcedureExpression
    to t : OUTMODEL!ProcedureExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule LinkEnd {
    from s : INMODEL!LinkEnd
    to t : OUTMODEL!LinkEnd mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        instance <- s.instance,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        associationEnd <- s.associationEnd,
        qualifiedValue <- s.qualifiedValue)
}

rule SynchState {
    from s : INMODEL!SynchState
    to t : OUTMODEL!SynchState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        bound <- s.bound,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule AssociationEndRole {
    from s : INMODEL!AssociationEndRole
    to t : OUTMODEL!AssociationEndRole mapsTo s (
        changeability <- s.changeability,
        multiplicity <- s.multiplicity,
        collaborationMultiplicity <- s.collaborationMultiplicity,
        targetScope <- s.targetScope,
        isNavigable <- s.isNavigable,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        aggregation <- s.aggregation,
        base <- s.base,
        stereotype <- s.stereotype,
        specification <- s.specification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        qualifier <- s.qualifier,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        participant <- s.participant,
        sourceFlow <- s.sourceFlow,
        availableQualifier <- s.availableQualifier)
}

rule StateMachine {
    from s : INMODEL!StateMachine (s.oclIsTypeOf(INMODEL!StateMachine))
    to t : OUTMODEL!StateMachine mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        submachineState <- s.submachineState,
        transitions <- s.transitions,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        top <- s.top)
}

rule Signal {
    from s : INMODEL!Signal (s.oclIsTypeOf(INMODEL!Signal))
    to t : OUTMODEL!Signal mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule BooleanExpression {
    from s : INMODEL!BooleanExpression
    to t : OUTMODEL!BooleanExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule CreateAction {
    from s : INMODEL!CreateAction
    to t : OUTMODEL!CreateAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        instantiation <- s.instantiation,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Model {
    from s : INMODEL!Model
    to t : OUTMODEL!Model mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        elementImport <- s.elementImport,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Constraint {
    from s : INMODEL!Constraint
    to t : OUTMODEL!Constraint mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        body <- s.body,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        constrainedElement <- s.constrainedElement,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule UseCaseInstance {
    from s : INMODEL!UseCaseInstance
    to t : OUTMODEL!UseCaseInstance mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        slot <- s.slot)
}

rule SendAction {
    from s : INMODEL!SendAction
    to t : OUTMODEL!SendAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        signal <- s.signal)
}

rule Pseudostate {
    from s : INMODEL!Pseudostate
    to t : OUTMODEL!Pseudostate mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        kind <- s.kind,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule DataType {
    from s : INMODEL!DataType (s.oclIsTypeOf(INMODEL!DataType))
    to t : OUTMODEL!DataType mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule Dependency {
    from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
    to t : OUTMODEL!Dependency mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        comment <- s.comment,
        client <- s.client,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ClassifierInState {
    from s : INMODEL!ClassifierInState
    to t : OUTMODEL!ClassifierInState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        inState <- s.inState,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        type <- s.type,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule SubsystemInstance {
    from s : INMODEL!SubsystemInstance
    to t : OUTMODEL!SubsystemInstance mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        slot <- s.slot)
}

rule Transition {
    from s : INMODEL!Transition
    to t : OUTMODEL!Transition mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        source <- s.source,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        guard <- s.guard,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        effect <- s.effect,
        target <- s.target,
        trigger <- s.trigger)
}

rule CallEvent {
    from s : INMODEL!CallEvent
    to t : OUTMODEL!CallEvent mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow,
        operation <- s.operation)
}

rule ActionState {
    from s : INMODEL!ActionState (s.oclIsTypeOf(INMODEL!ActionState))
    to t : OUTMODEL!ActionState mapsTo s (
        dynamicMultiplicity <- s.dynamicMultiplicity,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        isDynamic <- s.isDynamic,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule TaggedValue {
    from s : INMODEL!TaggedValue
    to t : OUTMODEL!TaggedValue mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        dataValue <- s.dataValue,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        type <- s.type,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        referenceValue <- s.referenceValue,
        sourceFlow <- s.sourceFlow)
}

rule TypeExpression {
    from s : INMODEL!TypeExpression
    to t : OUTMODEL!TypeExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule StubState {
    from s : INMODEL!StubState
    to t : OUTMODEL!StubState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        referenceState <- s.referenceState,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule DestroyAction {
    from s : INMODEL!DestroyAction
    to t : OUTMODEL!DestroyAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Expression {
    from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
    to t : OUTMODEL!Expression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule Artifact {
    from s : INMODEL!Artifact
    to t : OUTMODEL!Artifact mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule ProgrammingLanguageDataType {
    from s : INMODEL!ProgrammingLanguageDataType
    to t : OUTMODEL!ProgrammingLanguageDataType mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        expression <- s.expression,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule ComponentInstance {
    from s : INMODEL!ComponentInstance
    to t : OUTMODEL!ComponentInstance mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        nodeInstance <- s.nodeInstance,
        linkEnd <- s.linkEnd,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        resident <- s.resident,
        slot <- s.slot)
}

rule Interface {
    from s : INMODEL!Interface
    to t : OUTMODEL!Interface mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule UseCase {
    from s : INMODEL!UseCase
    to t : OUTMODEL!UseCase mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        extensionPoint <- s.extensionPoint,
        feature <- s.feature,
        extend <- s.extend,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        include <- s.include,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule Abstraction {
    from s : INMODEL!Abstraction
    to t : OUTMODEL!Abstraction mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        mapping <- s.mapping,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        comment <- s.comment,
        client <- s.client,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ExtensionPoint {
    from s : INMODEL!ExtensionPoint
    to t : OUTMODEL!ExtensionPoint mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        location <- s.location,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ReturnAction {
    from s : INMODEL!ReturnAction
    to t : OUTMODEL!ReturnAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule SignalEvent {
    from s : INMODEL!SignalEvent
    to t : OUTMODEL!SignalEvent mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        signal <- s.signal,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow)
}

rule Interaction {
    from s : INMODEL!Interaction
    to t : OUTMODEL!Interaction mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        message <- s.message,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule AssociationEnd {
    from s : INMODEL!AssociationEnd (s.oclIsTypeOf(INMODEL!AssociationEnd))
    to t : OUTMODEL!AssociationEnd mapsTo s (
        changeability <- s.changeability,
        multiplicity <- s.multiplicity,
        targetScope <- s.targetScope,
        isNavigable <- s.isNavigable,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        aggregation <- s.aggregation,
        stereotype <- s.stereotype,
        specification <- s.specification,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        qualifier <- s.qualifier,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        participant <- s.participant,
        sourceFlow <- s.sourceFlow)
}

rule TagDefinition {
    from s : INMODEL!TagDefinition
    to t : OUTMODEL!TagDefinition mapsTo s (
        multiplicity <- s.multiplicity,
        tagType <- s.tagType,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule ActionSequence {
    from s : INMODEL!ActionSequence
    to t : OUTMODEL!ActionSequence mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        action <- s.action)
}

rule Partition {
    from s : INMODEL!Partition
    to t : OUTMODEL!Partition mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        contents <- s.contents)
}

rule Primitive {
    from s : INMODEL!Primitive
    to t : OUTMODEL!Primitive mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow)
}

rule CallState {
    from s : INMODEL!CallState
    to t : OUTMODEL!CallState mapsTo s (
        dynamicMultiplicity <- s.dynamicMultiplicity,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        isDynamic <- s.isDynamic,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule AssociationRole {
    from s : INMODEL!AssociationRole
    to t : OUTMODEL!AssociationRole mapsTo s (
        name <- s.name,
        multiplicity <- s.multiplicity,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        conformingLink <- s.conformingLink,
        templateParameter <- s.templateParameter,
        connection <- s.connection,
        comment <- s.comment,
        constraint <- s.constraint,
        base <- s.base,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        message <- s.message,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule TimeExpression {
    from s : INMODEL!TimeExpression
    to t : OUTMODEL!TimeExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule ActivityGraph {
    from s : INMODEL!ActivityGraph
    to t : OUTMODEL!ActivityGraph mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        partition <- s.partition,
        comment <- s.comment,
        submachineState <- s.submachineState,
        transitions <- s.transitions,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        top <- s.top)
}

rule Method {
    from s : INMODEL!Method
    to t : OUTMODEL!Method mapsTo s (
        name <- s.name,
        body <- s.body,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownerScope <- s.ownerScope,
        isQuery <- s.isQuery,
        parameter <- s.parameter,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        specification <- s.specification,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule LinkObject {
    from s : INMODEL!LinkObject
    to t : OUTMODEL!LinkObject mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        ownedLink <- s.ownedLink,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        association <- s.association,
        targetFlow <- s.targetFlow,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        componentInstance <- s.componentInstance,
        slot <- s.slot)
}

rule ElementImport {
    from s : INMODEL!ElementImport
    to t : OUTMODEL!ElementImport mapsTo s (
        alias <- s.alias,
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        importedElement <- s.importedElement)
}

rule Stimulus {
    from s : INMODEL!Stimulus
    to t : OUTMODEL!Stimulus mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        receiver <- s.receiver,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        communicationLink <- s.communicationLink,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        sender <- s.sender,
        dispatchAction <- s.dispatchAction,
        argument <- s.argument)
}

rule Association {
    from s : INMODEL!Association (s.oclIsTypeOf(INMODEL!Association))
    to t : OUTMODEL!Association mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        templateParameter <- s.templateParameter,
        connection <- s.connection,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Attribute {
    from s : INMODEL!Attribute
    to t : OUTMODEL!Attribute mapsTo s (
        multiplicity <- s.multiplicity,
        initialValue <- s.initialValue,
        changeability <- s.changeability,
        name <- s.name,
        ordering <- s.ordering,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        targetScope <- s.targetScope,
        ownerScope <- s.ownerScope,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        type <- s.type,
        sourceFlow <- s.sourceFlow)
}

rule FinalState {
    from s : INMODEL!FinalState
    to t : OUTMODEL!FinalState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Reception {
    from s : INMODEL!Reception
    to t : OUTMODEL!Reception mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        specification <- s.specification,
        ownerScope <- s.ownerScope,
        isRoot <- s.isRoot,
        isQuery <- s.isQuery,
        isAbstract <- s.isAbstract,
        isLeaf <- s.isLeaf,
        parameter <- s.parameter,
        stereotype <- s.stereotype,
        signal <- s.signal,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Multiplicity {
    from s : INMODEL!Multiplicity
    to t : OUTMODEL!Multiplicity mapsTo s (
        range <- s.range)
}

rule ChangeEvent {
    from s : INMODEL!ChangeEvent
    to t : OUTMODEL!ChangeEvent mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        changeExpression <- s.changeExpression,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow)
}

rule TerminateAction {
    from s : INMODEL!TerminateAction
    to t : OUTMODEL!TerminateAction mapsTo s (
        target <- s.target,
        name <- s.name,
        visibility <- s.visibility,
        isAsynchronous <- s.isAsynchronous,
        recurrence <- s.recurrence,
        isSpecification <- s.isSpecification,
        script <- s.script,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        actualArgument <- s.actualArgument,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Collaboration {
    from s : INMODEL!Collaboration
    to t : OUTMODEL!Collaboration mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        representedOperation <- s.representedOperation,
        representedClassifier <- s.representedClassifier,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        interaction <- s.interaction,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        constrainingElement <- s.constrainingElement,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        usedCollaboration <- s.usedCollaboration)
}

rule Stereotype {
    from s : INMODEL!Stereotype
    to t : OUTMODEL!Stereotype mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        baseClass <- s.baseClass,
        icon <- s.icon,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotypeConstraint <- s.stereotypeConstraint,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        definedTag <- s.definedTag,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Generalization {
    from s : INMODEL!Generalization
    to t : OUTMODEL!Generalization mapsTo s (
        discriminator <- s.discriminator,
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        child <- s.child,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        parent <- s.parent,
        powertype <- s.powertype)
}

rule Parameter {
    from s : INMODEL!Parameter
    to t : OUTMODEL!Parameter mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        kind <- s.kind,
        isSpecification <- s.isSpecification,
        defaultValue <- s.defaultValue,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        type <- s.type,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Package {
    from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
    to t : OUTMODEL!Package mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        elementImport <- s.elementImport,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

rule Component {
    from s : INMODEL!Component
    to t : OUTMODEL!Component mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        isSpecification <- s.isSpecification,
        isRoot <- s.isRoot,
        isLeaf <- s.isLeaf,
        residentElement <- s.residentElement,
        stereotype <- s.stereotype,
        generalization <- s.generalization,
        feature <- s.feature,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        ownedElement <- s.ownedElement,
        clientDependency <- s.clientDependency,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        implementation <- s.implementation)
}

rule SubmachineState {
    from s : INMODEL!SubmachineState (s.oclIsTypeOf(INMODEL!SubmachineState))
    to t : OUTMODEL!SubmachineState mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        isConcurrent <- s.isConcurrent,
        stereotype <- s.stereotype,
        exit <- s.exit,
        entry <- s.entry,
        subvertex <- s.subvertex,
        templateParameter <- s.templateParameter,
        internalTransition <- s.internalTransition,
        submachine <- s.submachine,
        doActivity <- s.doActivity,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        incoming <- s.incoming,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow)
}

-- ======================================================================
-- model copy end
-- ======================================================================
