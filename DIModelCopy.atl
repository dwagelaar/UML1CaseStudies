-- Generated by: $Id: ModelCopyGenerator.atl 875 2005-04-20 13:46:26Z dwagelaa $
module DIModelCopy;

create OUT : OUTMODEL from IN : INMODEL;

rule ReturnAction {
    from s : INMODEL!ReturnAction
    to t : OUTMODEL!ReturnAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule ActionState {
    from s : INMODEL!ActionState (s.oclIsTypeOf(INMODEL!ActionState))
    to t : OUTMODEL!ActionState mapsTo s (
        visibility <- s.visibility,
        isDynamic <- s.isDynamic,
        name <- s.name,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        dynamicMultiplicity <- s.dynamicMultiplicity,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Constraint {
    from s : INMODEL!Constraint
    to t : OUTMODEL!Constraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        body <- s.body,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        constrainedElement <- s.constrainedElement,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Transition {
    from s : INMODEL!Transition
    to t : OUTMODEL!Transition mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        trigger <- s.trigger,
        templateParameter <- s.templateParameter,
        guard <- s.guard,
        taggedValue <- s.taggedValue,
        target <- s.target,
        clientDependency <- s.clientDependency,
        effect <- s.effect,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        source <- s.source)
}

rule Flow {
    from s : INMODEL!Flow
    to t : OUTMODEL!Flow mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        target <- s.target,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        source <- s.source)
}

rule Guard {
    from s : INMODEL!Guard
    to t : OUTMODEL!Guard mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        expression <- s.expression,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Exception {
    from s : INMODEL!Exception
    to t : OUTMODEL!Exception mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule FinalState {
    from s : INMODEL!FinalState
    to t : OUTMODEL!FinalState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Collaboration {
    from s : INMODEL!Collaboration
    to t : OUTMODEL!Collaboration mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        representedOperation <- s.representedOperation,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        interaction <- s.interaction,
        representedClassifier <- s.representedClassifier,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        usedCollaboration <- s.usedCollaboration,
        constrainingElement <- s.constrainingElement,
        generalization <- s.generalization)
}

rule ProcedureExpression {
    from s : INMODEL!ProcedureExpression
    to t : OUTMODEL!ProcedureExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule ComponentInstance {
    from s : INMODEL!ComponentInstance
    to t : OUTMODEL!ComponentInstance mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        resident <- s.resident,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd,
        nodeInstance <- s.nodeInstance)
}

rule Model {
    from s : INMODEL!Model
    to t : OUTMODEL!Model mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        elementImport <- s.elementImport,
        generalization <- s.generalization)
}

rule UseCase {
    from s : INMODEL!UseCase
    to t : OUTMODEL!UseCase mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        extend <- s.extend,
        ownedElement <- s.ownedElement,
        extensionPoint <- s.extensionPoint,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        include <- s.include,
        generalization <- s.generalization)
}

rule SignalEvent {
    from s : INMODEL!SignalEvent
    to t : OUTMODEL!SignalEvent mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        signal <- s.signal,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Parameter {
    from s : INMODEL!Parameter
    to t : OUTMODEL!Parameter mapsTo s (
        kind <- s.kind,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        defaultValue <- s.defaultValue,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        type <- s.type)
}

rule ObjectFlowState {
    from s : INMODEL!ObjectFlowState
    to t : OUTMODEL!ObjectFlowState mapsTo s (
        isSynch <- s.isSynch,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        type <- s.type,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule MultiplicityRange {
    from s : INMODEL!MultiplicityRange
    to t : OUTMODEL!MultiplicityRange mapsTo s (
        upper <- s.upper,
        lower <- s.lower)
}

rule TimeEvent {
    from s : INMODEL!TimeEvent
    to t : OUTMODEL!TimeEvent mapsTo s (
        when <- s.when,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Binding {
    from s : INMODEL!Binding
    to t : OUTMODEL!Binding mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        argument <- s.argument,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        client <- s.client)
}

rule CallState {
    from s : INMODEL!CallState
    to t : OUTMODEL!CallState mapsTo s (
        visibility <- s.visibility,
        isDynamic <- s.isDynamic,
        name <- s.name,
        isSpecification <- s.isSpecification,
        dynamicArguments <- s.dynamicArguments,
        dynamicMultiplicity <- s.dynamicMultiplicity,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule SimpleState {
    from s : INMODEL!SimpleState (s.oclIsTypeOf(INMODEL!SimpleState))
    to t : OUTMODEL!SimpleState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule TimeExpression {
    from s : INMODEL!TimeExpression
    to t : OUTMODEL!TimeExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule Dependency {
    from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
    to t : OUTMODEL!Dependency mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        client <- s.client)
}

rule Partition {
    from s : INMODEL!Partition
    to t : OUTMODEL!Partition mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        contents <- s.contents)
}

rule NodeInstance {
    from s : INMODEL!NodeInstance
    to t : OUTMODEL!NodeInstance mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        resident <- s.resident,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule CreateAction {
    from s : INMODEL!CreateAction
    to t : OUTMODEL!CreateAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        instantiation <- s.instantiation,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule ClassifierInState {
    from s : INMODEL!ClassifierInState
    to t : OUTMODEL!ClassifierInState mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        inState <- s.inState,
        ownedElement <- s.ownedElement,
        type <- s.type,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule DataType {
    from s : INMODEL!DataType (s.oclIsTypeOf(INMODEL!DataType))
    to t : OUTMODEL!DataType mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule AssociationEndRole {
    from s : INMODEL!AssociationEndRole
    to t : OUTMODEL!AssociationEndRole mapsTo s (
        isNavigable <- s.isNavigable,
        aggregation <- s.aggregation,
        targetScope <- s.targetScope,
        collaborationMultiplicity <- s.collaborationMultiplicity,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        changeability <- s.changeability,
        multiplicity <- s.multiplicity,
        comment <- s.comment,
        base <- s.base,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        participant <- s.participant,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        availableQualifier <- s.availableQualifier,
        specification <- s.specification,
        qualifier <- s.qualifier)
}

rule Extend {
    from s : INMODEL!Extend
    to t : OUTMODEL!Extend mapsTo s (
        condition <- s.condition,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        base <- s.base,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        extensionPoint <- s.extensionPoint,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        extension <- s.extension)
}

rule Message {
    from s : INMODEL!Message
    to t : OUTMODEL!Message mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        action <- s.action,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        communicationConnection <- s.communicationConnection,
        taggedValue <- s.taggedValue,
        sender <- s.sender,
        activator <- s.activator,
        clientDependency <- s.clientDependency,
        receiver <- s.receiver,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        conformingStimulus <- s.conformingStimulus,
        predecessor <- s.predecessor)
}

rule UseCaseInstance {
    from s : INMODEL!UseCaseInstance
    to t : OUTMODEL!UseCaseInstance mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule Reference {
    from s : INMODEL!Reference
    to t : OUTMODEL!Reference mapsTo s (
        isIndividualPresentation <- s.isIndividualPresentation,
        isVisible <- s.isVisible,
        reference <- s.reference,
        referenced <- s.referenced,
        property <- s.property)
}

rule AssociationClass {
    from s : INMODEL!AssociationClass
    to t : OUTMODEL!AssociationClass mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isActive <- s.isActive,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        connection <- s.connection,
        generalization <- s.generalization)
}

rule ArgListsExpression {
    from s : INMODEL!ArgListsExpression
    to t : OUTMODEL!ArgListsExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule IterationExpression {
    from s : INMODEL!IterationExpression
    to t : OUTMODEL!IterationExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule TemplateArgument {
    from s : INMODEL!TemplateArgument
    to t : OUTMODEL!TemplateArgument mapsTo s (
        modelElement <- s.modelElement)
}

rule DiagramLink {
    from s : INMODEL!DiagramLink
    to t : OUTMODEL!DiagramLink mapsTo s (
        zoom <- s.zoom,
        viewport <- s.viewport,
        diagram <- s.diagram)
}

rule Include {
    from s : INMODEL!Include
    to t : OUTMODEL!Include mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        addition <- s.addition,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        base <- s.base)
}

rule Generalization {
    from s : INMODEL!Generalization
    to t : OUTMODEL!Generalization mapsTo s (
        discriminator <- s.discriminator,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        powertype <- s.powertype,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        parent <- s.parent,
        child <- s.child,
        stereotype <- s.stereotype)
}

rule Uml1SemanticModelBridge {
    from s : INMODEL!Uml1SemanticModelBridge
    to t : OUTMODEL!Uml1SemanticModelBridge mapsTo s (
        presentation <- s.presentation,
        element <- s.element)
}

rule EnumerationLiteral {
    from s : INMODEL!EnumerationLiteral
    to t : OUTMODEL!EnumerationLiteral mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule StateMachine {
    from s : INMODEL!StateMachine (s.oclIsTypeOf(INMODEL!StateMachine))
    to t : OUTMODEL!StateMachine mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        submachineState <- s.submachineState,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        top <- s.top,
        stereotype <- s.stereotype,
        transitions <- s.transitions)
}

rule Association {
    from s : INMODEL!Association (s.oclIsTypeOf(INMODEL!Association))
    to t : OUTMODEL!Association mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        connection <- s.connection,
        generalization <- s.generalization)
}

rule AssociationRole {
    from s : INMODEL!AssociationRole
    to t : OUTMODEL!AssociationRole mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        multiplicity <- s.multiplicity,
        comment <- s.comment,
        conformingLink <- s.conformingLink,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        base <- s.base,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        connection <- s.connection,
        message <- s.message,
        generalization <- s.generalization)
}

rule TaggedValue {
    from s : INMODEL!TaggedValue
    to t : OUTMODEL!TaggedValue mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        dataValue <- s.dataValue,
        comment <- s.comment,
        referenceValue <- s.referenceValue,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        type <- s.type)
}

rule Reception {
    from s : INMODEL!Reception
    to t : OUTMODEL!Reception mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isSpecification <- s.isSpecification,
        specification <- s.specification,
        isAbstract <- s.isAbstract,
        isQuery <- s.isQuery,
        isRoot <- s.isRoot,
        ownerScope <- s.ownerScope,
        signal <- s.signal,
        comment <- s.comment,
        constraint <- s.constraint,
        parameter <- s.parameter,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Argument {
    from s : INMODEL!Argument
    to t : OUTMODEL!Argument mapsTo s (
        value <- s.value,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Polyline {
    from s : INMODEL!Polyline
    to t : OUTMODEL!Polyline mapsTo s (
        closed <- s.closed,
        waypoints <- s.waypoints,
        isVisible <- s.isVisible,
        reference <- s.reference,
        property <- s.property)
}

rule Abstraction {
    from s : INMODEL!Abstraction
    to t : OUTMODEL!Abstraction mapsTo s (
        visibility <- s.visibility,
        mapping <- s.mapping,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        client <- s.client)
}

rule ProgrammingLanguageDataType {
    from s : INMODEL!ProgrammingLanguageDataType
    to t : OUTMODEL!ProgrammingLanguageDataType mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        expression <- s.expression,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule Interaction {
    from s : INMODEL!Interaction
    to t : OUTMODEL!Interaction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        message <- s.message,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Actor {
    from s : INMODEL!Actor
    to t : OUTMODEL!Actor mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule ActivityGraph {
    from s : INMODEL!ActivityGraph
    to t : OUTMODEL!ActivityGraph mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        submachineState <- s.submachineState,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        top <- s.top,
        stereotype <- s.stereotype,
        transitions <- s.transitions,
        partition <- s.partition)
}

rule CallEvent {
    from s : INMODEL!CallEvent
    to t : OUTMODEL!CallEvent mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        operation <- s.operation,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Operation {
    from s : INMODEL!Operation
    to t : OUTMODEL!Operation mapsTo s (
        concurrency <- s.concurrency,
        specification <- s.specification,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isQuery <- s.isQuery,
        isAbstract <- s.isAbstract,
        isRoot <- s.isRoot,
        ownerScope <- s.ownerScope,
        isLeaf <- s.isLeaf,
        comment <- s.comment,
        constraint <- s.constraint,
        parameter <- s.parameter,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule AssociationEnd {
    from s : INMODEL!AssociationEnd (s.oclIsTypeOf(INMODEL!AssociationEnd))
    to t : OUTMODEL!AssociationEnd mapsTo s (
        isNavigable <- s.isNavigable,
        aggregation <- s.aggregation,
        targetScope <- s.targetScope,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        changeability <- s.changeability,
        multiplicity <- s.multiplicity,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        participant <- s.participant,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        specification <- s.specification,
        qualifier <- s.qualifier)
}

rule TemplateParameter {
    from s : INMODEL!TemplateParameter
    to t : OUTMODEL!TemplateParameter mapsTo s (
        parameter <- s.parameter,
        defaultElement <- s.defaultElement)
}

rule SynchState {
    from s : INMODEL!SynchState
    to t : OUTMODEL!SynchState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        bound <- s.bound,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule GraphConnector {
    from s : INMODEL!GraphConnector
    to t : OUTMODEL!GraphConnector mapsTo s (
        position <- s.position,
        graphEdge <- s.graphEdge)
}

rule ClassifierRole {
    from s : INMODEL!ClassifierRole
    to t : OUTMODEL!ClassifierRole mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        multiplicity <- s.multiplicity,
        comment <- s.comment,
        base <- s.base,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        availableFeature <- s.availableFeature,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        conformingInstance <- s.conformingInstance,
        availableContents <- s.availableContents,
        generalization <- s.generalization)
}

rule Stimulus {
    from s : INMODEL!Stimulus
    to t : OUTMODEL!Stimulus mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        dispatchAction <- s.dispatchAction,
        comment <- s.comment,
        constraint <- s.constraint,
        receiver <- s.receiver,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        sender <- s.sender,
        clientDependency <- s.clientDependency,
        argument <- s.argument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        communicationLink <- s.communicationLink)
}

rule LinkEnd {
    from s : INMODEL!LinkEnd
    to t : OUTMODEL!LinkEnd mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        instance <- s.instance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        qualifiedValue <- s.qualifiedValue,
        clientDependency <- s.clientDependency,
        associationEnd <- s.associationEnd,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule SubactivityState {
    from s : INMODEL!SubactivityState
    to t : OUTMODEL!SubactivityState mapsTo s (
        visibility <- s.visibility,
        dynamicMultiplicity <- s.dynamicMultiplicity,
        name <- s.name,
        isDynamic <- s.isDynamic,
        isSpecification <- s.isSpecification,
        isConcurrent <- s.isConcurrent,
        dynamicArguments <- s.dynamicArguments,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        subvertex <- s.subvertex,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        submachine <- s.submachine)
}

rule ObjectSetExpression {
    from s : INMODEL!ObjectSetExpression
    to t : OUTMODEL!ObjectSetExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule Permission {
    from s : INMODEL!Permission
    to t : OUTMODEL!Permission mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        client <- s.client)
}

rule ActionExpression {
    from s : INMODEL!ActionExpression
    to t : OUTMODEL!ActionExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule Signal {
    from s : INMODEL!Signal (s.oclIsTypeOf(INMODEL!Signal))
    to t : OUTMODEL!Signal mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule SubmachineState {
    from s : INMODEL!SubmachineState (s.oclIsTypeOf(INMODEL!SubmachineState))
    to t : OUTMODEL!SubmachineState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isConcurrent <- s.isConcurrent,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        subvertex <- s.subvertex,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        submachine <- s.submachine)
}

rule TerminateAction {
    from s : INMODEL!TerminateAction
    to t : OUTMODEL!TerminateAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule LinkObject {
    from s : INMODEL!LinkObject
    to t : OUTMODEL!LinkObject mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        association <- s.association,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule ElementImport {
    from s : INMODEL!ElementImport
    to t : OUTMODEL!ElementImport mapsTo s (
        alias <- s.alias,
        visibility <- s.visibility,
        isSpecification <- s.isSpecification,
        importedElement <- s.importedElement)
}

rule Property {
    from s : INMODEL!Property
    to t : OUTMODEL!Property mapsTo s (
        value <- s.value,
        key <- s.key)
}

rule GraphEdge {
    from s : INMODEL!GraphEdge
    to t : OUTMODEL!GraphEdge mapsTo s (
        waypoints <- s.waypoints,
        position <- s.position,
        isVisible <- s.isVisible,
        anchorage <- s.anchorage,
        anchor <- s.anchor,
        reference <- s.reference,
        link <- s.link,
        contained <- s.contained,
        semanticModel <- s.semanticModel,
        property <- s.property)
}

rule AttributeLink {
    from s : INMODEL!AttributeLink
    to t : OUTMODEL!AttributeLink mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        value <- s.value,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        attribute <- s.attribute)
}

rule Attribute {
    from s : INMODEL!Attribute
    to t : OUTMODEL!Attribute mapsTo s (
        multiplicity <- s.multiplicity,
        changeability <- s.changeability,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        ordering <- s.ordering,
        initialValue <- s.initialValue,
        targetScope <- s.targetScope,
        ownerScope <- s.ownerScope,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        type <- s.type)
}

rule Diagram {
    from s : INMODEL!Diagram
    to t : OUTMODEL!Diagram mapsTo s (
        zoom <- s.zoom,
        position <- s.position,
        name <- s.name,
        size <- s.size,
        viewport <- s.viewport,
        isVisible <- s.isVisible,
        anchorage <- s.anchorage,
        owner <- s.owner,
        reference <- s.reference,
        diagramLink <- s.diagramLink,
        link <- s.link,
        contained <- s.contained,
        semanticModel <- s.semanticModel,
        property <- s.property)
}

rule UninterpretedAction {
    from s : INMODEL!UninterpretedAction
    to t : OUTMODEL!UninterpretedAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Component {
    from s : INMODEL!Component
    to t : OUTMODEL!Component mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        residentElement <- s.residentElement,
        implementation <- s.implementation,
        generalization <- s.generalization)
}

rule DestroyAction {
    from s : INMODEL!DestroyAction
    to t : OUTMODEL!DestroyAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Artifact {
    from s : INMODEL!Artifact
    to t : OUTMODEL!Artifact mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule Enumeration {
    from s : INMODEL!Enumeration
    to t : OUTMODEL!Enumeration mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        literal <- s.literal,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule GraphNode {
    from s : INMODEL!GraphNode (s.oclIsTypeOf(INMODEL!GraphNode))
    to t : OUTMODEL!GraphNode mapsTo s (
        position <- s.position,
        size <- s.size,
        isVisible <- s.isVisible,
        anchorage <- s.anchorage,
        reference <- s.reference,
        link <- s.link,
        contained <- s.contained,
        semanticModel <- s.semanticModel,
        property <- s.property)
}

rule SubsystemInstance {
    from s : INMODEL!SubsystemInstance
    to t : OUTMODEL!SubsystemInstance mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule CoreSemanticModelBridge {
    from s : INMODEL!CoreSemanticModelBridge
    to t : OUTMODEL!CoreSemanticModelBridge mapsTo s (
        presentation <- s.presentation)
}

rule Subsystem {
    from s : INMODEL!Subsystem
    to t : OUTMODEL!Subsystem mapsTo s (
        isInstantiable <- s.isInstantiable,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        elementImport <- s.elementImport,
        generalization <- s.generalization)
}

rule TypeExpression {
    from s : INMODEL!TypeExpression
    to t : OUTMODEL!TypeExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule ChangeEvent {
    from s : INMODEL!ChangeEvent
    to t : OUTMODEL!ChangeEvent mapsTo s (
        changeExpression <- s.changeExpression,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        parameter <- s.parameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule CollaborationInstanceSet {
    from s : INMODEL!CollaborationInstanceSet
    to t : OUTMODEL!CollaborationInstanceSet mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        participatingLink <- s.participatingLink,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        collaboration <- s.collaboration,
        constrainingElement <- s.constrainingElement,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        interactionInstanceSet <- s.interactionInstanceSet,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        participatingInstance <- s.participatingInstance)
}

rule Pseudostate {
    from s : INMODEL!Pseudostate
    to t : OUTMODEL!Pseudostate mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        kind <- s.kind,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Expression {
    from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
    to t : OUTMODEL!Expression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule DataValue {
    from s : INMODEL!DataValue
    to t : OUTMODEL!DataValue mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule SendAction {
    from s : INMODEL!SendAction
    to t : OUTMODEL!SendAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        signal <- s.signal,
        stereotype <- s.stereotype)
}

rule Stereotype {
    from s : INMODEL!Stereotype
    to t : OUTMODEL!Stereotype mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        icon <- s.icon,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        baseClass <- s.baseClass,
        comment <- s.comment,
        stereotypeConstraint <- s.stereotypeConstraint,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        definedTag <- s.definedTag,
        generalization <- s.generalization)
}

rule MappingExpression {
    from s : INMODEL!MappingExpression
    to t : OUTMODEL!MappingExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule ElementResidence {
    from s : INMODEL!ElementResidence
    to t : OUTMODEL!ElementResidence mapsTo s (
        visibility <- s.visibility,
        resident <- s.resident)
}

rule Object {
    from s : INMODEL!Object (s.oclIsTypeOf(INMODEL!Object))
    to t : OUTMODEL!Object mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        slot <- s.slot,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        componentInstance <- s.componentInstance,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        classifier <- s.classifier,
        ownedLink <- s.ownedLink,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        ownedInstance <- s.ownedInstance,
        linkEnd <- s.linkEnd)
}

rule Package {
    from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
    to t : OUTMODEL!Package mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        elementImport <- s.elementImport,
        generalization <- s.generalization)
}

rule Node {
    from s : INMODEL!Node
    to t : OUTMODEL!Node mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        deployedComponent <- s.deployedComponent,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule Image {
    from s : INMODEL!Image
    to t : OUTMODEL!Image mapsTo s (
        mimeType <- s.mimeType,
        uri <- s.uri,
        isVisible <- s.isVisible,
        reference <- s.reference,
        property <- s.property)
}

rule InteractionInstanceSet {
    from s : INMODEL!InteractionInstanceSet
    to t : OUTMODEL!InteractionInstanceSet mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        interaction <- s.interaction,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        participatingStimulus <- s.participatingStimulus)
}

rule CallAction {
    from s : INMODEL!CallAction
    to t : OUTMODEL!CallAction mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        operation <- s.operation,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Class {
    from s : INMODEL!Class (s.oclIsTypeOf(INMODEL!Class))
    to t : OUTMODEL!Class mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isActive <- s.isActive,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule Usage {
    from s : INMODEL!Usage
    to t : OUTMODEL!Usage mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        supplier <- s.supplier,
        client <- s.client)
}

rule BooleanExpression {
    from s : INMODEL!BooleanExpression
    to t : OUTMODEL!BooleanExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule StubState {
    from s : INMODEL!StubState
    to t : OUTMODEL!StubState mapsTo s (
        referenceState <- s.referenceState,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        incoming <- s.incoming,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Multiplicity {
    from s : INMODEL!Multiplicity
    to t : OUTMODEL!Multiplicity mapsTo s (
        range <- s.range)
}

rule ActionSequence {
    from s : INMODEL!ActionSequence
    to t : OUTMODEL!ActionSequence mapsTo s (
        script <- s.script,
        visibility <- s.visibility,
        target <- s.target,
        name <- s.name,
        isSpecification <- s.isSpecification,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        action <- s.action)
}

rule Interface {
    from s : INMODEL!Interface
    to t : OUTMODEL!Interface mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule ExtensionPoint {
    from s : INMODEL!ExtensionPoint
    to t : OUTMODEL!ExtensionPoint mapsTo s (
        location <- s.location,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Comment {
    from s : INMODEL!Comment
    to t : OUTMODEL!Comment mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        body <- s.body,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        annotatedElement <- s.annotatedElement)
}

rule TagDefinition {
    from s : INMODEL!TagDefinition
    to t : OUTMODEL!TagDefinition mapsTo s (
        multiplicity <- s.multiplicity,
        tagType <- s.tagType,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule CompositeState {
    from s : INMODEL!CompositeState (s.oclIsTypeOf(INMODEL!CompositeState))
    to t : OUTMODEL!CompositeState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isConcurrent <- s.isConcurrent,
        internalTransition <- s.internalTransition,
        comment <- s.comment,
        exit <- s.exit,
        outgoing <- s.outgoing,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        deferrableEvent <- s.deferrableEvent,
        doActivity <- s.doActivity,
        clientDependency <- s.clientDependency,
        subvertex <- s.subvertex,
        incoming <- s.incoming,
        entry <- s.entry,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule TextElement {
    from s : INMODEL!TextElement
    to t : OUTMODEL!TextElement mapsTo s (
        text <- s.text,
        isVisible <- s.isVisible,
        reference <- s.reference,
        property <- s.property)
}

rule Link {
    from s : INMODEL!Link (s.oclIsTypeOf(INMODEL!Link))
    to t : OUTMODEL!Link mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        association <- s.association,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype)
}

rule Ellipse {
    from s : INMODEL!Ellipse
    to t : OUTMODEL!Ellipse mapsTo s (
        endAngle <- s.endAngle,
        rotation <- s.rotation,
        startAngle <- s.startAngle,
        center <- s.center,
        radiusY <- s.radiusY,
        isVisible <- s.isVisible,
        radiusX <- s.radiusX,
        reference <- s.reference,
        property <- s.property)
}

rule SimpleSemanticModelElement {
    from s : INMODEL!SimpleSemanticModelElement
    to t : OUTMODEL!SimpleSemanticModelElement mapsTo s (
        typeInfo <- s.typeInfo,
        presentation <- s.presentation)
}

rule Primitive {
    from s : INMODEL!Primitive
    to t : OUTMODEL!Primitive mapsTo s (
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        ownedElement <- s.ownedElement,
        powertypeRange <- s.powertypeRange,
        sourceFlow <- s.sourceFlow,
        stereotype <- s.stereotype,
        generalization <- s.generalization)
}

rule Method {
    from s : INMODEL!Method
    to t : OUTMODEL!Method mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isSpecification <- s.isSpecification,
        isQuery <- s.isQuery,
        ownerScope <- s.ownerScope,
        body <- s.body,
        comment <- s.comment,
        constraint <- s.constraint,
        parameter <- s.parameter,
        targetFlow <- s.targetFlow,
        templateParameter <- s.templateParameter,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        sourceFlow <- s.sourceFlow,
        specification <- s.specification,
        stereotype <- s.stereotype)
}

