-- $Id$
module Accessors;

create OUT : OUTMODEL from IN : INMODEL;

uses Java;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper context String def : dataType() : INMODEL!DataType =
	INMODEL!DataType.allInstances()->select(c|c.name=self)->first();

helper context String def : stereotype() : INMODEL!Stereotype =
	INMODEL!Stereotype.allInstances()->select(s|s.name=self)->first();

helper context INMODEL!AssociationEnd def : isSingle() : Boolean =
	self.multiplicity.range->select(r|r.upper<>1)->isEmpty();

helper context INMODEL!AssociationEnd def : otherEnd() : INMODEL!AssociationEnd =
	self.association.connection->select(x|x<>self)->first();

helper context INMODEL!AssociationEnd def : navigableFrom() : INMODEL!Classifier =
	self.otherEnd().participant;

helper context INMODEL!Attribute def : hasAssociationEnd() : Boolean =
	not INMODEL!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->isEmpty();

helper context INMODEL!Attribute def : associationEnd() : INMODEL!AssociationEnd =
	INMODEL!AssociationEnd.allInstances()->select(a|
		a.name=self.name and a.navigableFrom()=self.owner)->first();

helper context INMODEL!Attribute def : originalType() : INMODEL!Classifier =
	if self.hasAssociationEnd() then
		self.associationEnd().participant
	else
		self.type
	endif;

helper context INMODEL!Attribute def : dualSetter() : String =
	if not self.associationEnd().otherEnd().isNavigable then
		self.name.javaSetter()
	else if self.associationEnd().otherEnd().isSingle() then
		self.name.javaDualSetter(self.associationEnd().otherEnd().name.firstToUpper())
	else
		self.name.javaAddRemoveSetter(self.associationEnd().otherEnd().name.firstToUpper())
	endif endif;
	
helper context INMODEL!Attribute def : setter() : String =
	if self.hasAssociationEnd() then
		self.dualSetter()
	else
		self.name.javaSetter()
	endif;

helper context INMODEL!Attribute def : dualAdder() : String =
	if not self.associationEnd().otherEnd().isNavigable then
		self.name.java2Adder()
	else if self.associationEnd().otherEnd().isSingle() then
		self.name.java2SetterAdder(self.associationEnd().otherEnd().name.firstToUpper())
	else
		self.name.java2DualAdder(self.associationEnd().otherEnd().name.firstToUpper())
	endif endif;
	
helper context INMODEL!Attribute def : dualInsert() : String =
	if not self.associationEnd().otherEnd().isNavigable then
		self.name.java2Insert()
	else if self.associationEnd().otherEnd().isSingle() then
		self.name.java2SetterInsert(self.associationEnd().otherEnd().name.firstToUpper())
	else
		self.name.java2DualInsert(self.associationEnd().otherEnd().name.firstToUpper())
	endif endif;
	
helper context INMODEL!Attribute def : adder() : String =
	if self.hasAssociationEnd() then
		self.dualAdder()
	else
		self.name.java2Adder()
	endif;

helper context INMODEL!Attribute def : insert() : String =
	if self.hasAssociationEnd() then
		self.dualInsert()
	else
		self.name.java2Insert()
	endif;

helper context INMODEL!Attribute def : dualRemover() : String =
	if not self.associationEnd().otherEnd().isNavigable then
		self.name.java2Remover()
	else if self.associationEnd().otherEnd().isSingle() then
		self.name.java2SetterRemover(self.associationEnd().otherEnd().name.firstToUpper())
	else
		self.name.java2DualRemover(self.associationEnd().otherEnd().name.firstToUpper())
	endif endif;
	
helper context INMODEL!Attribute def : remover() : String =
	if self.hasAssociationEnd() then
		self.dualRemover()
	else
		self.name.java2Remover()
	endif;

helper context INMODEL!ModelElement def : isInPackage() : Boolean =
	not INMODEL!Package.allInstances()->select(p|
		p=self.namespace and p.oclIsTypeOf(INMODEL!Package))->isEmpty();

helper context INMODEL!ModelElement def : qName() : String =
	if self.isInPackage() then
		self.namespace.qName() + '.' + self.name
	else
		self.name
	endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================
	
-- ======================================================================
-- non-mapsTo rules begin
-- ======================================================================

rule PublicAttributeSetter {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public and
		not s.type.name.isCollection())
	to op : OUTMODEL!Operation (
	   	name <- 'set' + s.name.firstToUpper(),
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par : OUTMODEL!Parameter (
	   	name <- s.name,
		behavioralFeature <- op,
		type <- s.type,
		kind <- #pdk_in),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.setter()),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'set' + s.name.firstToUpper() + '()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

rule PublicAttributeGetter {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public)
	to op : OUTMODEL!Operation (
	   	name <- 'get' + s.name.firstToUpper() + s.type.name.s(),
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par : OUTMODEL!Parameter (
	   	name <- 'return',
		behavioralFeature <- op,
		type <- s.type,
		kind <- #pdk_return),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.name.javaGetter()),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'get' + s.name.firstToUpper() + s.type.name.s() + '()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

rule PublicAttributeGetAt {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public and
		s.type.name.isSequence())
	to op : OUTMODEL!Operation (
	   	name <- 'get' + s.name.firstToUpper() + 'At',
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par1 : OUTMODEL!Parameter (
	   	name <- 'index',
		behavioralFeature <- op,
		type <- 'Integer'.dataType(),
		kind <- #pdk_in),
	   par2 : OUTMODEL!Parameter (
	   	name <- 'return',
		behavioralFeature <- op,
		type <- s.originalType(),
		kind <- #pdk_return),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.name.java2GetAt(s.originalType().qName())),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'get' + s.name.firstToUpper() + 'At()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

rule PublicAttributeAdder {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public and
		s.type.name.isCollection())
	to op : OUTMODEL!Operation (
	   	name <- 'add' + s.name.firstToUpper(),
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par : OUTMODEL!Parameter (
	   	name <- s.name,
		behavioralFeature <- op,
		type <- s.originalType(),
		kind <- #pdk_in),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.adder()),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'add' + s.name.firstToUpper() + '()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

rule PublicAttributeInsert {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public and
		s.type.name.isSequence())
	to op : OUTMODEL!Operation (
	   	name <- 'insert' + s.name.firstToUpper(),
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par1 : OUTMODEL!Parameter (
	   	name <- s.name,
		behavioralFeature <- op,
		type <- s.originalType(),
		kind <- #pdk_in),
	   par2 : OUTMODEL!Parameter (
	   	name <- 'index',
		behavioralFeature <- op,
		type <- 'Integer'.dataType(),
		kind <- #pdk_in),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.insert()),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'insert' + s.name.firstToUpper() + '()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

rule PublicAttributeRemover {
	from s : INMODEL!Attribute (
		s.visibility = #vk_public and
		s.type.name.isCollection())
	to op : OUTMODEL!Operation (
	   	name <- 'remove' + s.name.firstToUpper(),
		owner <- s.owner,
		visibility <- s.visibility,
		ownerScope <- s.ownerScope,
		isAbstract <- false,
		concurrency <- #cck_sequential),
	   par : OUTMODEL!Parameter (
	   	name <- s.name,
		behavioralFeature <- op,
		type <- s.originalType(),
		kind <- #pdk_in),
	   mbody : OUTMODEL!ProcedureExpression (
	   	language <- 'java',
		body <- s.remover()),
	   meth : OUTMODEL!Method (
	   	owner <- s.owner,
		body <- mbody,
		specification <- op),
	   dep : OUTMODEL!Dependency (
	   	name <- 'accessor ' + 'remove' + s.name.firstToUpper() + '()',
		namespace <- s.owner.namespace,
		stereotype <- 'accessor'.stereotype(),
		client <- op,
		supplier <- s)
}

-- ======================================================================
-- non-mapsTo rules end
-- ======================================================================

-- ======================================================================
-- mapsTo rules begin
-- ======================================================================

rule Attribute {
    from s : INMODEL!Attribute
	using { vis : INMODEL!VisibilityKind =
		if s.visibility = #vk_public then #vk_private else s.visibility	endif; }
    to t : OUTMODEL!Attribute mapsTo s (
        multiplicity <- s.multiplicity,
        initialValue <- s.initialValue,
        changeability <- s.changeability,
        name <- s.name,
        ordering <- s.ordering,
        visibility <- vis,
        isSpecification <- s.isSpecification,
        targetScope <- s.targetScope,
        ownerScope <- s.ownerScope,
        stereotype <- s.stereotype,
        templateParameter <- s.templateParameter,
        comment <- s.comment,
        constraint <- s.constraint,
        targetFlow <- s.targetFlow,
        taggedValue <- s.taggedValue,
        clientDependency <- s.clientDependency,
        type <- s.type,
        sourceFlow <- s.sourceFlow)
}

-- ======================================================================
-- mapsTo rules end
-- ======================================================================

-- ======================================================================
-- model copy begin
-- ======================================================================
-- Generated by: ModelCopyGenerator.atl 1087 dwagelaa

rule Parameter {
    from s : INMODEL!Parameter
    to t : OUTMODEL!Parameter mapsTo s (
        isSpecification <- s.isSpecification,
        kind <- s.kind,
        visibility <- s.visibility,
        defaultValue <- s.defaultValue,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        type <- s.type,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Operation {
    from s : INMODEL!Operation
    to t : OUTMODEL!Operation mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        concurrency <- s.concurrency,
        specification <- s.specification,
        isQuery <- s.isQuery,
        visibility <- s.visibility,
        ownerScope <- s.ownerScope,
        name <- s.name,
        isAbstract <- s.isAbstract,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Include {
    from s : INMODEL!Include
    to t : OUTMODEL!Include mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        base <- s.base,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency,
        addition <- s.addition)
}

rule Object {
    from s : INMODEL!Object (s.oclIsTypeOf(INMODEL!Object))
    to t : OUTMODEL!Object mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        linkEnd <- s.linkEnd,
        ownedInstance <- s.ownedInstance,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        classifier <- s.classifier,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        ownedLink <- s.ownedLink,
        componentInstance <- s.componentInstance,
        slot <- s.slot,
        clientDependency <- s.clientDependency)
}

rule TagDefinition {
    from s : INMODEL!TagDefinition
    to t : OUTMODEL!TagDefinition mapsTo s (
        isSpecification <- s.isSpecification,
        multiplicity <- s.multiplicity,
        tagType <- s.tagType,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Multiplicity {
    from s : INMODEL!Multiplicity
    to t : OUTMODEL!Multiplicity mapsTo s (
        range <- s.range)
}

rule Class {
    from s : INMODEL!Class (s.oclIsTypeOf(INMODEL!Class))
    to t : OUTMODEL!Class mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        powertypeRange <- s.powertypeRange,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        clientDependency <- s.clientDependency)
}

rule Stereotype {
    from s : INMODEL!Stereotype
    to t : OUTMODEL!Stereotype mapsTo s (
        isSpecification <- s.isSpecification,
        icon <- s.icon,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        baseClass <- s.baseClass,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        definedTag <- s.definedTag,
        templateParameter <- s.templateParameter,
        stereotypeConstraint <- s.stereotypeConstraint,
        clientDependency <- s.clientDependency)
}

rule Collaboration {
    from s : INMODEL!Collaboration
    to t : OUTMODEL!Collaboration mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        representedClassifier <- s.representedClassifier,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        interaction <- s.interaction,
        taggedValue <- s.taggedValue,
        constrainingElement <- s.constrainingElement,
        templateParameter <- s.templateParameter,
        representedOperation <- s.representedOperation,
        usedCollaboration <- s.usedCollaboration,
        clientDependency <- s.clientDependency)
}

rule CallAction {
    from s : INMODEL!CallAction
    to t : OUTMODEL!CallAction mapsTo s (
        isSpecification <- s.isSpecification,
        target <- s.target,
        visibility <- s.visibility,
        name <- s.name,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        script <- s.script,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        operation <- s.operation,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Model {
    from s : INMODEL!Model
    to t : OUTMODEL!Model mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        elementImport <- s.elementImport,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ReturnAction {
    from s : INMODEL!ReturnAction
    to t : OUTMODEL!ReturnAction mapsTo s (
        isSpecification <- s.isSpecification,
        target <- s.target,
        visibility <- s.visibility,
        name <- s.name,
        recurrence <- s.recurrence,
        isAsynchronous <- s.isAsynchronous,
        script <- s.script,
        actualArgument <- s.actualArgument,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule LinkEnd {
    from s : INMODEL!LinkEnd
    to t : OUTMODEL!LinkEnd mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        associationEnd <- s.associationEnd,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        instance <- s.instance,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency,
        qualifiedValue <- s.qualifiedValue)
}

rule Abstraction {
    from s : INMODEL!Abstraction
    to t : OUTMODEL!Abstraction mapsTo s (
        isSpecification <- s.isSpecification,
        mapping <- s.mapping,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        supplier <- s.supplier,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        client <- s.client,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule MultiplicityRange {
    from s : INMODEL!MultiplicityRange
    to t : OUTMODEL!MultiplicityRange mapsTo s (
        lower <- s.lower,
        upper <- s.upper)
}

rule Argument {
    from s : INMODEL!Argument
    to t : OUTMODEL!Argument mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        value <- s.value,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Stimulus {
    from s : INMODEL!Stimulus
    to t : OUTMODEL!Stimulus mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        receiver <- s.receiver,
        dispatchAction <- s.dispatchAction,
        sourceFlow <- s.sourceFlow,
        argument <- s.argument,
        communicationLink <- s.communicationLink,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        sender <- s.sender,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Dependency {
    from s : INMODEL!Dependency (s.oclIsTypeOf(INMODEL!Dependency))
    to t : OUTMODEL!Dependency mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        supplier <- s.supplier,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        client <- s.client,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Actor {
    from s : INMODEL!Actor
    to t : OUTMODEL!Actor mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        powertypeRange <- s.powertypeRange,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        clientDependency <- s.clientDependency)
}

rule UseCase {
    from s : INMODEL!UseCase
    to t : OUTMODEL!UseCase mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        include <- s.include,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        extensionPoint <- s.extensionPoint,
        stereotype <- s.stereotype,
        powertypeRange <- s.powertypeRange,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        clientDependency <- s.clientDependency,
        extend <- s.extend)
}

rule Link {
    from s : INMODEL!Link (s.oclIsTypeOf(INMODEL!Link))
    to t : OUTMODEL!Link mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        association <- s.association,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        connection <- s.connection,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Message {
    from s : INMODEL!Message
    to t : OUTMODEL!Message mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        conformingStimulus <- s.conformingStimulus,
        communicationConnection <- s.communicationConnection,
        sourceFlow <- s.sourceFlow,
        receiver <- s.receiver,
        comment <- s.comment,
        predecessor <- s.predecessor,
        stereotype <- s.stereotype,
        activator <- s.activator,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        action <- s.action,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        sender <- s.sender,
        clientDependency <- s.clientDependency)
}

rule InteractionInstanceSet {
    from s : INMODEL!InteractionInstanceSet
    to t : OUTMODEL!InteractionInstanceSet mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        participatingStimulus <- s.participatingStimulus,
        templateParameter <- s.templateParameter,
        interaction <- s.interaction,
        clientDependency <- s.clientDependency)
}

rule Interface {
    from s : INMODEL!Interface
    to t : OUTMODEL!Interface mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        powertypeRange <- s.powertypeRange,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        clientDependency <- s.clientDependency)
}

rule TaggedValue {
    from s : INMODEL!TaggedValue
    to t : OUTMODEL!TaggedValue mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        dataValue <- s.dataValue,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        type <- s.type,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        referenceValue <- s.referenceValue,
        clientDependency <- s.clientDependency)
}

rule AssociationEnd {
    from s : INMODEL!AssociationEnd (s.oclIsTypeOf(INMODEL!AssociationEnd))
    to t : OUTMODEL!AssociationEnd mapsTo s (
        isSpecification <- s.isSpecification,
        targetScope <- s.targetScope,
        visibility <- s.visibility,
        ordering <- s.ordering,
        changeability <- s.changeability,
        isNavigable <- s.isNavigable,
        aggregation <- s.aggregation,
        multiplicity <- s.multiplicity,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        qualifier <- s.qualifier,
        specification <- s.specification,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        participant <- s.participant,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule Association {
    from s : INMODEL!Association (s.oclIsTypeOf(INMODEL!Association))
    to t : OUTMODEL!Association mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        connection <- s.connection,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule CollaborationInstanceSet {
    from s : INMODEL!CollaborationInstanceSet
    to t : OUTMODEL!CollaborationInstanceSet mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        sourceFlow <- s.sourceFlow,
        participatingInstance <- s.participatingInstance,
        interactionInstanceSet <- s.interactionInstanceSet,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        participatingLink <- s.participatingLink,
        clientDependency <- s.clientDependency,
        collaboration <- s.collaboration,
        constrainingElement <- s.constrainingElement)
}

rule Method {
    from s : INMODEL!Method
    to t : OUTMODEL!Method mapsTo s (
        isSpecification <- s.isSpecification,
        isQuery <- s.isQuery,
        visibility <- s.visibility,
        ownerScope <- s.ownerScope,
        name <- s.name,
        body <- s.body,
        parameter <- s.parameter,
        sourceFlow <- s.sourceFlow,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency,
        specification <- s.specification)
}

rule Generalization {
    from s : INMODEL!Generalization
    to t : OUTMODEL!Generalization mapsTo s (
        isSpecification <- s.isSpecification,
        visibility <- s.visibility,
        name <- s.name,
        discriminator <- s.discriminator,
        powertype <- s.powertype,
        sourceFlow <- s.sourceFlow,
        child <- s.child,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        parent <- s.parent,
        clientDependency <- s.clientDependency)
}

rule Package {
    from s : INMODEL!Package (s.oclIsTypeOf(INMODEL!Package))
    to t : OUTMODEL!Package mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        elementImport <- s.elementImport,
        templateParameter <- s.templateParameter,
        clientDependency <- s.clientDependency)
}

rule ProcedureExpression {
    from s : INMODEL!ProcedureExpression
    to t : OUTMODEL!ProcedureExpression mapsTo s (
        language <- s.language,
        body <- s.body)
}

rule DataType {
    from s : INMODEL!DataType (s.oclIsTypeOf(INMODEL!DataType))
    to t : OUTMODEL!DataType mapsTo s (
        isSpecification <- s.isSpecification,
        isLeaf <- s.isLeaf,
        isRoot <- s.isRoot,
        visibility <- s.visibility,
        isAbstract <- s.isAbstract,
        name <- s.name,
        generalization <- s.generalization,
        sourceFlow <- s.sourceFlow,
        ownedElement <- s.ownedElement,
        comment <- s.comment,
        stereotype <- s.stereotype,
        powertypeRange <- s.powertypeRange,
        targetFlow <- s.targetFlow,
        constraint <- s.constraint,
        taggedValue <- s.taggedValue,
        templateParameter <- s.templateParameter,
        feature <- s.feature,
        clientDependency <- s.clientDependency)
}

rule Expression {
    from s : INMODEL!Expression (s.oclIsTypeOf(INMODEL!Expression))
    to t : OUTMODEL!Expression mapsTo s (
        language <- s.language,
        body <- s.body)
}

-- ======================================================================
-- model copy end
-- ======================================================================
